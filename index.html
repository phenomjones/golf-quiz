
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Flight Master</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="app"></div>
    <script>
        // Simple state management
        let state = {
            user: null,
            showAuth: true,
            showLevelSelect: false,
            username: '',
            scenarioNumber: 1,
            currentCard: 1,
            selectedAnswer: null,
            showExplanation: false,
            isCorrect: null,
            difficulty: 1,
            showDifficultySelector: false,
            currentScenarioData: null,
            showConfidenceBoost: false,
            confidenceMultiplier: 1,
            hasUsedBoost: false,
            boostCountdown: 20,
            boostTimer: null,
            boostCardResults: [], // Track card results for multi-card scenarios
            boostLost: false
        };

        const difficultyLevels = [
            { level: 1, name: "Beginner", description: "Basic club data only", baseReward: 10, cards: 1, details: "Start your journey! Learn the fundamentals with basic club face and path data." },
            { level: 2, name: "Casual Golfer", description: "Basic club data with variation", baseReward: 15, cards: 1, details: "Build on the basics with more variety in club speeds and angles." },
            { level: 3, name: "Club Player", description: "Heel/toe impact added", baseReward: 25, cards: 2, details: "Impact location added. Learn how gear effect creates draws from heel hits and fades from toe hits." },
            { level: 4, name: "Scratch Golfer", description: "More extreme heel/toe mishits", baseReward: 40, cards: 2, details: "Face more challenging mishits with extreme heel and toe contacts." },
            { level: 5, name: "Advanced Amateur", description: "High/low face impact added", baseReward: 60, cards: 3, details: "Vertical impact matters! High and low face strikes are introduced along with spin loft data." },
            { level: 6, name: "Mini-Tour Pro", description: "More severe high/low mishits", baseReward: 85, cards: 3, details: "Handle extreme vertical mishits that drastically affect launch and spin." },
            { level: 7, name: "PGA Tour Player", description: "Wind conditions added", baseReward: 115, cards: 3, details: "Wind conditions (headwind, tailwind, crosswind) are now part of the equation." },
            { level: 8, name: "Tour Champion", description: "More complex wind patterns", baseReward: 150, cards: 3, details: "Face stronger and more complex wind scenarios that significantly alter ball flight." },
            { level: 9, name: "Major Winner", description: "Lie conditions added", baseReward: 200, cards: 3, details: "Uphill, downhill, and sidehill lies are added. Every factor matters now." },
            { level: 10, name: "PGA Pro Master", description: "All conditions, extreme scenarios", baseReward: 300, cards: 3, details: "The pinnacle of ball flight mastery. Extreme scenarios with all variables at play." }
        ];

        const shotShapeDescriptions = {
            "Straight": "No curve",
            "Draw": "Moderate left curve",
            "Fade": "Moderate right curve",
            "Baby draw": "Slight left curve",
            "Baby fade": "Slight right curve",
            "Big draw": "Heavy left curve",
            "Big fade": "Heavy right curve",
            "Hook": "Severe left curve",
            "Slice": "Severe right curve",
            "Push-draw": "Starts right, curves left",
            "Push-fade": "Starts right, curves right",
            "Pull-draw": "Starts left, curves left",
            "Pull-fade": "Starts left, curves right",
            "Push-hook": "Starts right, extreme left",
            "Pull-hook": "Starts left, extreme left",
            "Block-slice": "Starts right, severe right",
            "Pull-slice": "Starts left, extreme right"
        };

        function generateScenario(diffLevel) {
            const baseClubSpeed = { driver: 105, wood: 95, iron: 85, wedge: 75 };
            const baseCarryDistance = { driver: 250, wood: 220, iron: 165, wedge: 120 };
            const clubs = diffLevel <= 2 ? ["7 Iron"] : 
                         diffLevel <= 5 ? ["Driver", "5 Wood", "7 Iron"] :
                         ["Driver", "3 Wood", "5 Iron", "7 Iron", "PW"];
            const club = clubs[Math.floor(Math.random() * clubs.length)];
            
            const clubType = club.includes("Driver") ? "driver" : 
                             club.includes("Wood") ? "wood" : 
                             club.includes("PW") ? "wedge" : "iron";
            
            // Club-specific physics
            const clubPhysics = {
                driver: { startFaceInfluence: 0.85, curveMultiplier: 6, loft: 10, gearMultiplier: 0.6 },
                wood: { startFaceInfluence: 0.82, curveMultiplier: 5, loft: 18, gearMultiplier: 0.5 },
                iron: { startFaceInfluence: 0.75, curveMultiplier: 4, loft: 34, gearMultiplier: 0.3 },
                wedge: { startFaceInfluence: 0.70, curveMultiplier: 3, loft: 50, gearMultiplier: 0.15 }
            };
            const physics = clubPhysics[clubType];
            
            const speedVariance = diffLevel % 2 === 0 ? 15 : 10;
            
            let speed = baseClubSpeed[clubType] + (Math.random() * speedVariance - speedVariance/2);
            let carry = baseCarryDistance[clubType] + (Math.random() * (speedVariance * 2) - speedVariance);
            
            // Bell curve distribution for angles using Box-Muller transform
            // This creates a normal distribution centered at 0
            function bellCurve(min, max, stdDev) {
                // Box-Muller transform for normal distribution
                let u1 = Math.random();
                let u2 = Math.random();
                let z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                // Scale to desired std deviation and clamp to range
                let value = z * stdDev;
                return Math.max(min, Math.min(max, value));
            }
            
            // Face: bell curve with std dev of 3¬∞ (most shots within ¬±3¬∞)
            let face = bellCurve(-11, 11, 3);
            face = parseFloat(face.toFixed(1));
            
            // Path: bell curve with std dev of 3.5¬∞ (slightly wider than face)
            let path = bellCurve(-11, 11, 3.5);
            path = parseFloat(path.toFixed(1));
            
            let gearEffect = 0; // Will be set if impact location exists
            let windEffect = 0; // Will be set if wind exists
            let windDir = "";
            let impactLocationText = "";
            
            let faceDisplay = face + "¬∞";
            let pathDisplay = path + "¬∞";
            
            faceDisplay += face > 0 ? " (right)" : face < 0 ? " (left)" : "";
            pathDisplay += path > 0 ? " (right)" : path < 0 ? " (left)" : "";
            
            let data = {
                "Club / Speed / Carry": {
                    icon: "üèåÔ∏è",
                    label: "Club / Speed / Carry",
                    value: club + " ‚Ä¢ " + speed.toFixed(1) + " mph ‚Ä¢ " + Math.round(carry) + " yards"
                },
                "Club Face": {
                    icon: "üéØ",
                    label: "Club Face",
                    value: faceDisplay
                },
                "Club Path": {
                    icon: "‚Ü™Ô∏è",
                    label: "Club Path",
                    value: pathDisplay
                }
            };
            
            if (diffLevel >= 3) {
                const maxImpact = diffLevel === 3 ? 6 : 12;
                const impact = Math.random() * maxImpact - maxImpact/2;
                const impactSide = impact > 0 ? "toe" : "heel";
                data["Impact Location"] = {
                    icon: "üìç",
                    label: "Impact Location",
                    value: Math.abs(impact).toFixed(1) + "mm " + impactSide
                };
                
                // Gear effect: heel creates FADE spin (negative impact = positive gear effect = fade)
                // toe creates DRAW spin (positive impact = negative gear effect = draw)
                gearEffect = impact * -physics.gearMultiplier;
                impactLocationText = Math.abs(impact).toFixed(1) + "mm " + impactSide;
            }
            
            if (diffLevel >= 5) {
                data["Spin Loft"] = {
                    icon: "üîÑ",
                    label: "Spin Loft",
                    value: (Math.random() * 8 + 10).toFixed(1) + "¬∞"
                };
            }
            
            if (diffLevel >= 7) {
                const windSpeed = Math.floor(Math.random() * (diffLevel === 7 ? 15 : 25) + 5);
                const windDirs = ["Headwind", "Tailwind", "Left-to-Right", "Right-to-Left"];
                windDir = windDirs[Math.floor(Math.random() * windDirs.length)];
                data["Wind"] = {
                    icon: "üí®",
                    label: "Wind",
                    value: windSpeed + " mph " + windDir
                };
                
                // Wind effect on offline distance
                if (windDir === "Left-to-Right") windEffect = windSpeed * 0.3; // Push ball right
                else if (windDir === "Right-to-Left") windEffect = windSpeed * -0.3; // Push ball left
                // Headwind/tailwind affect distance but not lateral position as much
            }
            
            if (diffLevel >= 9) {
                const lies = ["Flat", "Uphill 3¬∞", "Downhill 3¬∞", "Ball above feet", "Ball below feet"];
                data["Lie"] = {
                    icon: "‚õ∞Ô∏è",
                    label: "Lie",
                    value: lies[Math.floor(Math.random() * lies.length)]
                };
            }

            const faceToPath = face - path + gearEffect;
            const startDir = face > 0 ? "right" : face < 0 ? "left" : "straight";
            
            // Determine shape based on tighter thresholds
            const absFTP = Math.abs(faceToPath);
            const curveType = absFTP <= 0.5 ? "straight" : absFTP <= 1.5 ? "slight" : absFTP <= 3.0 ? "moderate" : absFTP <= 5.0 ? "heavy" : "extreme";
            const startType = Math.abs(face) <= 1 ? "straight" : face > 1 ? "push" : "pull";
            const isDrawCurve = faceToPath < 0;
            
            let shape = "Straight";
            let shapeDesc = "on target, no curve";
            
            if (curveType !== "straight") {
                const curveNames = {
                    slight: isDrawCurve ? ["Baby draw", "starts straight, slight curve left"] : ["Baby fade", "starts straight, slight curve right"],
                    moderate: isDrawCurve ? ["Draw", "starts straight, curves left"] : ["Fade", "starts straight, curves right"],
                    heavy: isDrawCurve ? ["Big draw", "starts straight, heavy curve left"] : ["Big fade", "starts straight, heavy curve right"],
                    extreme: isDrawCurve ? ["Hook", "starts straight, severe curve left"] : ["Slice", "starts straight, severe curve right"]
                };
                
                if (startType === "straight") {
                    [shape, shapeDesc] = curveNames[curveType];
                } else if (startType === "push") {
                    if (curveType === "slight") [shape, shapeDesc] = isDrawCurve ? ["Push-draw", "starts right, curves back left"] : ["Push-fade", "starts right, curves further right"];
                    else if (curveType === "moderate") [shape, shapeDesc] = isDrawCurve ? ["Push-draw", "starts right, curves back left"] : ["Push-fade", "starts right, curves further right"];
                    else if (curveType === "heavy") [shape, shapeDesc] = isDrawCurve ? ["Push-draw", "starts right, curves strongly back left"] : ["Push-slice", "starts right, curves severely right"];
                    else [shape, shapeDesc] = isDrawCurve ? ["Push-hook", "starts right, severe curve back left"] : ["Push-slice", "starts right, extreme curve right"];
                } else {
                    if (curveType === "slight" || curveType === "moderate") [shape, shapeDesc] = isDrawCurve ? ["Pull-hook", "starts left, curves further left"] : ["Pull-fade", "starts left, curves back right"];
                    else [shape, shapeDesc] = isDrawCurve ? ["Pull-hook", "starts left, curves severely left"] : ["Pull-slice", "starts left, curves strongly back right"];
                }
            } else {
                if (startType === "push") [shape, shapeDesc] = ["Push", "starts right, flies straight"];
                else if (startType === "pull") [shape, shapeDesc] = ["Pull", "starts left, flies straight"];
            }

            const cards = [];
            const allShapes = ["Straight", "Push", "Pull", "Baby draw", "Baby fade", "Draw", "Fade", "Big draw", "Big fade", "Hook", "Slice", "Push-draw", "Push-fade", "Push-hook", "Push-slice", "Pull-hook", "Pull-fade", "Pull-slice"];
            const wrongShapes = allShapes.filter(s => s !== shape).sort(() => Math.random() - 0.5).slice(0, 3);
            const options = [shape, ...wrongShapes].sort(() => Math.random() - 0.5);
            
            // Always show descriptions for all levels
            const optionsWithDescriptions = options.map(o => o + " (" + getShapeDesc(o) + ")");
            
            // Build explanation for Card 1 (shot shape)
            let explanationParts = [];
            explanationParts.push(`<strong>Club:</strong> ${club} (${physics.loft}¬∞ loft)`);
            explanationParts.push(`<strong>Face:</strong> ${face}¬∞`);
            explanationParts.push(`<strong>Path:</strong> ${path}¬∞`);
            explanationParts.push(`<strong>Face-to-path:</strong> ${(face - path).toFixed(1)}¬∞`);
            
            if (gearEffect !== 0) {
                const gearDir = gearEffect > 0 ? "fade" : "draw";
                explanationParts.push(`<strong>Gear effect:</strong> ${impactLocationText} = ${Math.abs(gearEffect).toFixed(1)}¬∞ ${gearDir} spin`);
                explanationParts.push(`<strong>Total face-to-path:</strong> ${faceToPath.toFixed(1)}¬∞ (with gear effect)`);
            }
            
            explanationParts.push(`<strong>Result:</strong> ${shape} - ${shapeDesc}`);
            
            const card1Explanation = '<div class="space-y-1">' + explanationParts.map(p => '<div>' + p + '</div>').join('') + '</div>';
            
            cards.push({
                question: "What will be the shot shape?",
                options: optionsWithDescriptions,
                correct: shape + " (" + shapeDesc + ")",
                correctBase: shape,
                explanation: card1Explanation
            });
            
            if (diffLevel >= 3) {
                cards.push({
                    question: "Will the ball start left or right of the target?",
                    options: ["Left of target", "Right of target", "Straight at target"],
                    correct: face < -0.5 ? "Left of target" : face > 0.5 ? "Right of target" : "Straight at target",
                    explanation: `<div><strong>Face angle:</strong> ${face}¬∞</div><div><strong>Club:</strong> ${club} (${Math.round(physics.startFaceInfluence * 100)}% face influence)</div><div>The ball starts <strong>${startDir}</strong> because face angle controls ${Math.round(physics.startFaceInfluence * 100)}% of initial direction for this club.</div>`
                });
            }
            
            if (diffLevel >= 5) {
                // Calculate components with club-specific physics
                const faceContribution = face * 3; // Keep sign - positive = right, negative = left
                const baseFaceToPath = face - path; // WITHOUT gear effect
                const baseCurveContribution = baseFaceToPath * physics.curveMultiplier; // Use club-specific multiplier
                const gearContribution = gearEffect * physics.curveMultiplier; // Gear effect also uses club multiplier
                const curveContribution = baseCurveContribution + gearContribution; // Total curve
                
                // Net offline is: where it starts (face) + how much it curves (total)
                const netOffline = faceContribution + curveContribution + windEffect;
                const offlineYards = Math.abs(netOffline);
                const roundedYards = Math.round(offlineYards);
                const offlineDir = netOffline > 0 ? "right" : "left";
                
                let opts, corr;
                
                if (diffLevel <= 6) {
                    // 7-yard ranges
                    opts = [
                        `0-6 yards ${offlineDir}`,
                        `7-13 yards ${offlineDir}`,
                        `14-20 yards ${offlineDir}`,
                        `21-27 yards ${offlineDir}`,
                        `28-34 yards ${offlineDir}`,
                        `35+ yards ${offlineDir}`
                    ];
                    corr = roundedYards <= 6 ? opts[0] : roundedYards <= 13 ? opts[1] : roundedYards <= 20 ? opts[2] : roundedYards <= 27 ? opts[3] : roundedYards <= 34 ? opts[4] : opts[5];
                } else if (diffLevel <= 8) {
                    // 5-yard ranges
                    opts = [
                        `0-4 yards ${offlineDir}`,
                        `5-9 yards ${offlineDir}`,
                        `10-14 yards ${offlineDir}`,
                        `15-19 yards ${offlineDir}`,
                        `20-24 yards ${offlineDir}`,
                        `25+ yards ${offlineDir}`
                    ];
                    corr = roundedYards <= 4 ? opts[0] : roundedYards <= 9 ? opts[1] : roundedYards <= 14 ? opts[2] : roundedYards <= 19 ? opts[3] : roundedYards <= 24 ? opts[4] : opts[5];
                } else {
                    // 3-yard ranges for level 9-10
                    opts = [
                        `0-2 yards ${offlineDir}`,
                        `3-5 yards ${offlineDir}`,
                        `6-8 yards ${offlineDir}`,
                        `9-11 yards ${offlineDir}`,
                        `12-14 yards ${offlineDir}`,
                        `15+ yards ${offlineDir}`
                    ];
                    corr = roundedYards <= 2 ? opts[0] : roundedYards <= 5 ? opts[1] : roundedYards <= 8 ? opts[2] : roundedYards <= 11 ? opts[3] : roundedYards <= 14 ? opts[4] : opts[5];
                }
                
                // Build detailed calculation explanation
                // baseFaceToPath already calculated above
                let calcParts = [];
                
                // Show start position from face (keep precision)
                const faceDir = faceContribution > 0 ? "right" : "left";
                const faceYards = Math.abs(faceContribution);
                calcParts.push(`<strong>Start direction (face):</strong> ${face}¬∞ = ${faceYards.toFixed(1)} yards ${faceDir}`);
                
                // Show base curve from face-to-path (keep precision)
                const baseFTPDir = baseFaceToPath < 0 ? "draw" : "fade";
                const baseFTPYards = Math.abs(baseCurveContribution);
                const baseFTPSign = baseFaceToPath < 0 ? "left" : "right";
                calcParts.push(`<strong>Face-to-path curve:</strong> ${baseFaceToPath.toFixed(1)}¬∞ ${baseFTPDir} = ${baseFTPYards.toFixed(1)} yards ${baseFTPSign}`);
                
                // Show gear effect if present (keep precision)
                if (gearEffect !== 0) {
                    const gearDir = gearEffect > 0 ? "fade" : "draw";
                    const gearYards = Math.abs(gearContribution);
                    const gearSign = gearEffect > 0 ? "right" : "left";
                    const gearRelation = (gearEffect > 0 && baseFaceToPath > 0) || (gearEffect < 0 && baseFaceToPath < 0) ? "additional" : "opposing";
                    calcParts.push(`<strong>Gear effect (${gearRelation}):</strong> ${impactLocationText} creates ${Math.abs(gearEffect).toFixed(1)}¬∞ ${gearDir} spin = ${gearYards.toFixed(1)} yards ${gearSign}`);
                }
                
                // Show wind if present (keep precision)
                if (windEffect !== 0) {
                    const windSign = windEffect > 0 ? "right" : "left";
                    const windYards = Math.abs(windEffect);
                    calcParts.push(`<strong>Wind:</strong> ${windDir} = ${windYards.toFixed(1)} yards ${windSign}`);
                }
                
                // Show net calculation with ALL THREE components separately
                let netCalcParts = [];
                netCalcParts.push(`${faceContribution > 0 ? '+' : ''}${faceContribution.toFixed(1)} ${faceContribution > 0 ? 'right' : 'left'}`);
                netCalcParts.push(`${baseCurveContribution > 0 ? '+' : ''}${baseCurveContribution.toFixed(1)} ${baseCurveContribution > 0 ? 'right' : 'left'}`);
                
                if (gearEffect !== 0) {
                    netCalcParts.push(`${gearContribution > 0 ? '+' : ''}${gearContribution.toFixed(1)} ${gearContribution > 0 ? 'right' : 'left'}`);
                }
                
                if (windEffect !== 0) {
                    netCalcParts.push(`${windEffect > 0 ? '+' : ''}${windEffect.toFixed(1)} ${windEffect > 0 ? 'right' : 'left'}`);
                }
                
                const netCalc = netCalcParts.join(' ') + ` = ${netOffline.toFixed(1)} yards`;
                
                calcParts.push(`<strong>Net calculation:</strong> ${netCalc}`);
                calcParts.push(`<strong>Final result:</strong> ${roundedYards} yards ${offlineDir}`);
                
                cards.push({
                    question: "How far offline will the ball finish from the target?",
                    options: opts,
                    correct: corr,
                    explanation: '<div class="space-y-1">' + calcParts.map(p => '<div>' + p + '</div>').join('') + '</div>'
                });
            }
            
            return { data, cards };
        }

        function getShapeDesc(name) {
            const descs = {
                "Straight": "on target, no curve", "Push": "starts right, flies straight", "Pull": "starts left, flies straight",
                "Baby draw": "slight curve left", "Baby fade": "slight curve right",
                "Draw": "curves left", "Fade": "curves right",
                "Big draw": "heavy curve left", "Big fade": "heavy curve right",
                "Hook": "severe curve left", "Slice": "severe curve right",
                "Push-draw": "starts right, curves left", "Push-fade": "starts right, curves right",
                "Push-hook": "starts right, severe curve left", "Push-slice": "starts right, extreme curve right",
                "Pull-hook": "starts left, curves left", "Pull-fade": "starts left, curves right",
                "Pull-slice": "starts left, severe curve right"
            };
            return descs[name] || name;
        }

        async function saveScore() {
            if (!state.user) return;
            
            const timestamp = new Date().toISOString();
            const scoreData = {
                name: state.user.name,
                level: state.difficulty,
                tokens: state.user.tokens,
                questionsAnswered: state.user.questionsAnswered,
                correctAnswers: state.user.correctAnswers,
                accuracy: state.user.questionsAnswered > 0 ? 
                    Math.round((state.user.correctAnswers / state.user.questionsAnswered) * 100) : 0,
                bestStreak: state.user.bestStreak,
                timestamp: timestamp,
                displayTime: new Date(timestamp).toLocaleString()
            };
            
            const key = 'score_' + state.user.name + '_' + Date.now();
            
            // Try window.storage first (global), fallback to localStorage
            try {
                await window.storage.set(key, JSON.stringify(scoreData), true);
            } catch (error) {
                // Fallback to localStorage
                try {
                    localStorage.setItem(key, JSON.stringify(scoreData));
                } catch (e) {
                    console.log('Storage not available:', e.message);
                }
            }
        }

        async function loadLeaderboard() {
            let isGlobal = false;
            let scores = [];
            
            // Try window.storage first (global)
            try {
                const result = await window.storage.list('score_', true);
                if (result && result.keys) {
                    isGlobal = true;
                    for (const key of result.keys) {
                        try {
                            const scoreResult = await window.storage.get(key, true);
                            if (scoreResult && scoreResult.value) {
                                scores.push(JSON.parse(scoreResult.value));
                            }
                        } catch (e) {
                            console.error('Failed to load score:', e);
                        }
                    }
                }
            } catch (error) {
                // Fallback to localStorage
                try {
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('score_')) {
                            const value = localStorage.getItem(key);
                            if (value) {
                                scores.push(JSON.parse(value));
                            }
                        }
                    }
                } catch (e) {
                    console.error('Failed to load from localStorage:', e);
                }
            }
            
            scores.sort((a, b) => {
                if (b.tokens !== a.tokens) return b.tokens - a.tokens;
                return new Date(b.timestamp) - new Date(a.timestamp);
            });
            
            return { scores: scores.slice(0, 50), isGlobal };
        }

        function openLeaderboard() {
            const leaderboardWindow = window.open('', 'Leaderboard', 'width=1100,height=700');
            
            loadLeaderboard().then(data => {
                const { scores, isGlobal } = data;
                
                let html = `<!DOCTYPE html>
<html>
<head>
    <title>Leaderboard</title>
    <script src="https://cdn.tailwindcss.com"><` + `/script>
    <style>
        th { cursor: pointer; user-select: none; }
        th:hover { background-color: #f3f4f6; }
        .sort-arrow { display: inline-block; margin-left: 4px; }
    </style>
</head>
<body class="bg-gradient-to-br from-yellow-400 via-orange-500 to-red-600 p-8">
    <div class="max-w-6xl mx-auto bg-white rounded-2xl shadow-2xl p-8">
        <h1 class="text-4xl font-bold text-center mb-4 bg-gradient-to-r from-yellow-500 to-orange-500 bg-clip-text text-transparent">
            üèÜ Leaderboard
        </h1>
        <div class="text-center mb-6">
            <span class="inline-block px-4 py-2 rounded-full text-sm font-semibold ${isGlobal ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'}">
                ${isGlobal ? 'üåç Global Leaderboard - Compete with players worldwide!' : 'üìä Personal High Scores - Playing in local mode'}
            </span>
        </div>
        
        <div class="mb-4">
            <label class="font-semibold mr-2">Filter by Level:</label>
            <select id="levelFilter" onchange="filterScores()" class="px-4 py-2 border-2 border-gray-300 rounded-lg">
                <option value="all">All Levels</option>`;
                
                for (let i = 1; i <= 10; i++) {
                    html += `<option value="${i}">Level ${i}: ${difficultyLevels[i-1].name}</option>`;
                }
                
                html += `
            </select>
        </div>`;
                
                if (scores.length === 0) {
                    html += '<div class="text-center py-12"><p class="text-xl text-gray-600">No scores yet. Be the first!</p></div>';
                } else {
                    html += `
        <div class="overflow-x-auto">
            <table class="w-full" id="leaderboardTable">
                <thead>
                    <tr class="border-b-2 border-gray-300">
                        <th class="text-left py-3 px-4 font-bold text-gray-700">Rank</th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700">Player</th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700">Level</th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('tokens')">Tokens <span class="sort-arrow" id="arrow-tokens">‚Üì</span></th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('accuracy')">Accuracy <span class="sort-arrow" id="arrow-accuracy"></span></th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('correctAnswers')">Correct <span class="sort-arrow" id="arrow-correctAnswers"></span></th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('bestStreak')">Best Streak <span class="sort-arrow" id="arrow-bestStreak"></span></th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('timestamp')">Last Played <span class="sort-arrow" id="arrow-timestamp"></span></th>
                    </tr>
                </thead>
                <tbody id="leaderboardBody">
                </tbody>
            </table>
        </div>`;
                }
                
                html += `
    </div>
    <script>
        let allScores = ${JSON.stringify(scores)};
        let currentSort = { field: 'tokens', ascending: false };
        let currentFilter = 'all';
        
        const difficultyLevels = ${JSON.stringify(difficultyLevels)};
        
        function renderTable(scoresToShow) {
            const tbody = document.getElementById('leaderboardBody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            scoresToShow.forEach((score, idx) => {
                const medal = idx === 0 ? 'ü•á' : idx === 1 ? 'ü•à' : idx === 2 ? 'ü•â' : (idx + 1);
                const rowClass = idx < 3 ? 'bg-yellow-50' : '';
                const row = document.createElement('tr');
                row.className = 'border-b border-gray-200 hover:bg-gray-50 ' + rowClass;
                row.innerHTML = \`
                    <td class="py-3 px-4 font-semibold">\${medal}</td>
                    <td class="py-3 px-4 font-medium">\${score.name}</td>
                    <td class="py-3 px-4"><span class="text-sm">\${difficultyLevels[score.level - 1].name}</span></td>
                    <td class="py-3 px-4"><span class="font-bold text-blue-600">\${score.tokens}</span></td>
                    <td class="py-3 px-4"><span class="text-sm">\${score.accuracy}%</span></td>
                    <td class="py-3 px-4"><span class="font-bold text-green-600">\${score.correctAnswers}</span></td>
                    <td class="py-3 px-4"><span class="font-bold text-purple-600">\${score.bestStreak || 0}</span></td>
                    <td class="py-3 px-4 text-sm text-gray-600">\${score.displayTime}</td>
                \`;
                tbody.appendChild(row);
            });
        }
        
        function sortBy(field) {
            if (currentSort.field === field) {
                currentSort.ascending = !currentSort.ascending;
            } else {
                currentSort.field = field;
                currentSort.ascending = field === 'timestamp';
            }
            
            // Clear all arrows
            document.querySelectorAll('.sort-arrow').forEach(el => el.textContent = '');
            
            // Set current arrow
            const arrow = document.getElementById('arrow-' + field);
            if (arrow) arrow.textContent = currentSort.ascending ? '‚Üë' : '‚Üì';
            
            const filtered = filterScores(true);
            const sorted = [...filtered].sort((a, b) => {
                let aVal = a[field];
                let bVal = b[field];
                
                if (field === 'timestamp') {
                    aVal = new Date(aVal);
                    bVal = new Date(bVal);
                }
                
                if (currentSort.ascending) {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });
            
            renderTable(sorted);
        }
        
        function filterScores(returnOnly = false) {
            currentFilter = document.getElementById('levelFilter').value;
            
            let filtered = allScores;
            if (currentFilter !== 'all') {
                filtered = allScores.filter(s => s.level === parseInt(currentFilter));
            }
            
            if (returnOnly) return filtered;
            
            sortBy(currentSort.field);
        }
        
        // Initial render
        renderTable(allScores);
    <` + `/script>
</body>
</html>`;
                
                leaderboardWindow.document.write(html);
                leaderboardWindow.document.close();
            });
        }

        function selectLevel(level) {
            state.difficulty = level;
            render();
        }

        function startGame() {
            state.showLevelSelect = false;
            state.currentScenarioData = generateScenario(state.difficulty);
            maybeShowConfidenceBoost();
            render();
        }

        function maybeShowConfidenceBoost() {
            // Random chance (20%) to show confidence boost
            if (Math.random() < 0.2 && !state.showConfidenceBoost) {
                state.showConfidenceBoost = true;
                state.hasUsedBoost = false;
                state.boostCountdown = 20;
                // 50% chance to show before question, 50% after seeing the question
                state.boostTiming = Math.random() < 0.5 ? 'before' : 'after';
                
                // Start countdown timer
                if (state.boostTimer) clearInterval(state.boostTimer);
                state.boostTimer = setInterval(() => {
                    state.boostCountdown--;
                    if (state.boostCountdown <= 0) {
                        clearInterval(state.boostTimer);
                        state.showConfidenceBoost = false;
                        state.confidenceMultiplier = 1;
                    }
                    render();
                }, 1000);
            }
        }

        function selectConfidence(multiplier) {
            state.confidenceMultiplier = multiplier;
            state.showConfidenceBoost = false;
            state.hasUsedBoost = true;
            state.boostCardResults = [];
            state.boostLost = false;
            if (state.boostTimer) {
                clearInterval(state.boostTimer);
                state.boostTimer = null;
            }
            render();
        }

        function render() {
            const app = document.getElementById('app');
            
            if (state.showAuth) {
                app.innerHTML = `
                    <div class="min-h-screen bg-gradient-to-br from-green-900 via-blue-900 to-purple-900 p-6 flex items-center justify-center">
                        <div class="bg-white rounded-lg shadow-2xl max-w-md w-full">
                            <div class="bg-gradient-to-r from-green-600 to-blue-600 text-white p-6 rounded-t-lg">
                                <h1 class="text-3xl font-bold text-center">Ball Flight Master</h1>
                            </div>
                            <div class="p-8">
                                <div class="text-center mb-6">
                                    <div class="text-6xl mb-4">üéØ</div>
                                    <p class="text-gray-600 mb-6">Master the physics of golf ball flight</p>
                                </div>
                                <input type="text" id="username" value="${state.username}" 
                                    placeholder="Enter your username" 
                                    class="w-full p-3 border-2 border-gray-300 rounded-lg mb-4 text-lg">
                                <button onclick="handleLogin()" 
                                    class="w-full py-3 bg-gradient-to-r from-green-600 to-blue-600 text-white rounded-lg font-semibold text-lg hover:from-green-700 hover:to-blue-700">
                                    Start Playing
                                </button>
                                <button onclick="openLeaderboard()" 
                                    class="w-full mt-3 py-3 bg-purple-600 text-white rounded-lg font-semibold hover:bg-purple-700">
                                    üèÜ View Leaderboard
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                document.getElementById('username').addEventListener('input', e => {
                    state.username = e.target.value;
                });
                return;
            }

            if (state.showLevelSelect) {
                app.innerHTML = `
                    <div class="min-h-screen bg-gradient-to-br from-green-400 via-blue-500 to-purple-600 p-4">
                        <div class="max-w-6xl mx-auto">
                            <div class="bg-white rounded-2xl shadow-2xl p-8 mb-4">
                                <h1 class="text-4xl font-bold text-center mb-2 bg-gradient-to-r from-green-600 to-blue-600 bg-clip-text text-transparent">
                                    Welcome, ${state.username}!
                                </h1>
                                <p class="text-center text-gray-600 mb-6">Choose your starting level</p>
                                
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    ${difficultyLevels.map(level => `
                                        <div class="border-2 ${state.difficulty === level.level ? 'border-blue-500 bg-blue-50' : 'border-gray-300'} rounded-xl p-6 cursor-pointer hover:shadow-lg transition-all"
                                            onclick="selectLevel(${level.level})">
                                            <div class="flex items-start justify-between mb-3">
                                                <div>
                                                    <h3 class="text-xl font-bold text-gray-900">Level ${level.level}: ${level.name}</h3>
                                                    <p class="text-sm text-gray-600 mt-1">${level.description}</p>
                                                </div>
                                                <span class="bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm font-semibold">
                                                    +${level.baseReward} tokens
                                                </span>
                                            </div>
                                            
                                            <div class="bg-gray-50 rounded-lg p-4 mb-3">
                                                <p class="text-sm text-gray-700">${level.details}</p>
                                            </div>
                                            
                                            <div class="flex gap-4 text-sm">
                                                <div class="flex items-center gap-2">
                                                    <span class="text-gray-600">Cards:</span>
                                                    <span class="font-semibold">${level.cards}</span>
                                                </div>
                                                <div class="flex items-center gap-2">
                                                    <span class="text-gray-600">Reward:</span>
                                                    <span class="font-semibold text-green-600">+${level.baseReward}</span>
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                                
                                <button onclick="startGame()" 
                                    class="w-full mt-6 py-4 bg-gradient-to-r from-green-600 to-blue-600 text-white rounded-lg font-semibold text-lg hover:shadow-lg transition-all">
                                    Start Level ${state.difficulty}: ${difficultyLevels[state.difficulty - 1].name}
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                return;
            }

            if (!state.currentScenarioData) return;

            const totalCards = difficultyLevels[state.difficulty - 1].cards;
            const card = state.currentScenarioData.cards[state.currentCard - 1];
            const accuracy = state.user.questionsAnswered > 0 ? Math.round((state.user.correctAnswers / state.user.questionsAnswered) * 100) : 0;

            let dataHTML = '';
            for (let [key, item] of Object.entries(state.currentScenarioData.data)) {
                dataHTML += `
                    <div class="bg-gradient-to-br from-blue-50 to-indigo-50 border-2 border-blue-200 rounded-xl p-5 shadow-md hover:shadow-lg transition-all">
                        <div class="flex items-center gap-3 mb-2">
                            <span class="text-3xl">${item.icon}</span>
                            <span class="font-bold text-gray-700 text-sm">${item.label}</span>
                        </div>
                        <div class="text-xl font-bold text-gray-900 mt-2">${item.value}</div>
                    </div>
                `;
            }

            let optionsHTML = '';
            card.options.forEach((opt, idx) => {
                const description = shotShapeDescriptions[opt] || '';
                let btnClass = "w-full text-left p-5 rounded-xl border-2 transition-all font-semibold shadow-md hover:shadow-lg";
                if (!state.showExplanation) {
                    btnClass += state.selectedAnswer === opt ? " border-purple-600 bg-purple-600 text-white" : " border-gray-300 bg-white hover:border-purple-400 hover:bg-purple-50";
                } else {
                    const isCorrect = card.correctBase ? opt.split(' (')[0] === card.correctBase : opt === card.correct;
                    if (isCorrect) btnClass += " border-green-600 bg-green-500 text-white";
                    else if (opt === state.selectedAnswer) btnClass += " border-red-600 bg-red-500 text-white";
                    else btnClass += " border-gray-300 bg-gray-200 text-gray-500";
                }
                
                optionsHTML += `
                    <button onclick="handleAnswer('${opt.replace(/'/g, "\\'")}')" 
                        ${state.showExplanation ? 'disabled' : ''}
                        class="${btnClass}">
                        <div class="text-lg font-bold mb-1">${opt}</div>
                        ${description ? `<div class="text-sm opacity-80">${description}</div>` : ''}
                    </button>
                `;
            });

            app.innerHTML = `
                <div class="min-h-screen bg-gradient-to-br from-green-900 via-blue-900 to-purple-900 p-6">
                    <div class="max-w-5xl mx-auto">
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                            <div class="bg-gradient-to-br from-yellow-400 to-orange-500 text-white shadow-lg rounded-lg p-4 text-center">
                                <p class="text-sm opacity-90">Tokens</p>
                                <p class="text-2xl font-bold">${state.user.tokens}</p>
                            </div>
                            <div class="bg-gradient-to-br from-purple-500 to-pink-500 text-white shadow-lg rounded-lg p-4 text-center">
                                <p class="text-sm opacity-90">Accuracy</p>
                                <p class="text-2xl font-bold">${accuracy}%</p>
                            </div>
                            <div class="bg-gradient-to-br from-green-500 to-teal-500 text-white shadow-lg rounded-lg p-4 text-center">
                                <p class="text-sm opacity-90">Correct</p>
                                <p class="text-2xl font-bold">${state.user.correctAnswers}</p>
                            </div>
                            <div class="bg-gradient-to-br from-blue-500 to-indigo-500 text-white shadow-lg rounded-lg p-4 text-center">
                                <p class="text-sm opacity-90">Streak</p>
                                <p class="text-2xl font-bold">${state.user.currentStreak} üî•</p>
                            </div>
                        </div>

                        ${state.hasUsedBoost ? `
                            <div class="mb-6 p-4 rounded-xl shadow-lg ${state.boostLost ? 'bg-gray-300 opacity-75' : 'bg-gradient-to-r from-yellow-400 to-orange-500'}">
                                <div class="text-center">
                                    <div class="text-2xl font-bold ${state.boostLost ? 'text-gray-700' : 'text-white'} mb-2">
                                        ${state.boostLost ? '‚ùå' : 'üéØ'} ${state.boostLost ? '<span class="line-through">' + state.confidenceMultiplier + 'x</span>' : state.confidenceMultiplier + 'x'} BOOST ${state.boostLost ? 'LOST' : 'ACTIVE'}
                                    </div>
                                    <div class="flex justify-center items-center gap-2 mb-2">
                                        <span class="${state.boostLost ? 'text-gray-700' : 'text-white'} font-semibold">Progress:</span>
                                        ${Array.from({length: difficultyLevels[state.difficulty - 1].cards}, (_, i) => {
                                            if (i < state.boostCardResults.length) {
                                                return state.boostCardResults[i] ? '<span class="text-2xl">‚úì</span>' : '<span class="text-2xl text-red-600">‚úó</span>';
                                            } else {
                                                return '<span class="text-2xl text-white">‚óã</span>';
                                            }
                                        }).join('')}
                                        <span class="${state.boostLost ? 'text-gray-700' : 'text-white'} text-sm">(${state.boostCardResults.length}/${difficultyLevels[state.difficulty - 1].cards} cards)</span>
                                    </div>
                                    ${state.boostLost ? `
                                        <div class="text-sm text-gray-700 font-semibold">Failed Card ${state.boostCardResults.findIndex(r => !r) + 1}</div>
                                    ` : state.boostCardResults.length > 0 && state.boostCardResults.length < difficultyLevels[state.difficulty - 1].cards ? `
                                        <div class="text-sm text-white font-semibold">Still eligible! ${difficultyLevels[state.difficulty - 1].cards - state.boostCardResults.length} card(s) remaining</div>
                                    ` : ''}
                                </div>
                            </div>
                        ` : ''}

                        <div class="bg-white rounded-lg shadow-lg p-4 mb-6">
                            <div class="flex justify-between items-center">
                                <div>
                                    <h3 class="font-bold text-lg">Level ${state.difficulty} - ${difficultyLevels[state.difficulty - 1].name}</h3>
                                    <p class="text-sm text-gray-600">${difficultyLevels[state.difficulty - 1].description}</p>
                                </div>
                                <button onclick="toggleDifficulty()" class="px-4 py-2 bg-blue-600 text-white rounded-lg mr-2">
                                    Change Level
                                </button>
                                <button onclick="openLeaderboard()" class="px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600">
                                    üèÜ
                                </button>
                            </div>
                            ${state.showDifficultySelector ? `
                                <div class="mt-4">
                                    <input type="range" min="1" max="10" value="${state.difficulty}" 
                                        oninput="changeDifficulty(this.value)" class="w-full">
                                    <div class="flex justify-between text-xs text-gray-600 mt-2">
                                        ${difficultyLevels.map(d => `<span class="${d.level === state.difficulty ? 'font-bold text-blue-600' : ''}">${d.level}</span>`).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>

                        <div class="bg-white rounded-lg shadow-2xl">
                            <div class="bg-gradient-to-r from-green-600 to-blue-600 text-white p-6 rounded-t-lg">
                                <h2 class="text-2xl font-bold">Level ${state.difficulty} ‚Ä¢ Scenario #${state.scenarioNumber} ‚Ä¢ Card ${state.currentCard} of ${totalCards}</h2>
                                <p class="text-green-100">Base Reward: ${difficultyLevels[state.difficulty - 1].baseReward} tokens</p>
                            </div>
                            <div class="p-6">
                                <div class="mb-6">
                                    <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                                        ${dataHTML}
                                    </div>
                                </div>

                                ${state.showConfidenceBoost && !state.selectedAnswer && state.boostTiming === 'before' ? `
                                    <div class="mb-6 p-6 bg-gradient-to-r from-yellow-400 to-orange-500 border-4 border-yellow-600 rounded-xl shadow-2xl">
                                        <h3 class="text-3xl font-bold text-white mb-3 text-center">üéØ CONFIDENCE BOOSTER! üéØ</h3>
                                        <p class="text-white text-lg mb-4 text-center">We're showing you this BEFORE revealing the question! This is a true test of confidence.</p>
                                        <p class="text-white font-semibold mb-4 text-center">Choose your multiplier now, then answer the question:</p>
                                        
                                        <!-- Bomb Countdown -->
                                        <div class="mb-4 bg-white/30 rounded-lg p-3">
                                            <div class="flex items-center justify-between mb-2">
                                                <span class="text-white font-bold">Time remaining: ${state.boostCountdown}s</span>
                                                <span class="text-white font-bold">${state.boostCountdown <= 5 ? '‚ö†Ô∏è HURRY!' : ''}</span>
                                            </div>
                                            <div class="relative h-8 bg-white/20 rounded-full overflow-hidden">
                                                <div class="absolute top-0 left-0 h-full bg-red-500/50 transition-all duration-1000" style="width: ${(state.boostCountdown / 20) * 100}%"></div>
                                                <div class="absolute top-1/2 -translate-y-1/2 transition-all duration-1000" style="left: ${((20 - state.boostCountdown) / 20) * 100}%">
                                                    <span class="text-3xl">${state.boostCountdown <= 3 ? 'üí•' : 'üí£'}</span>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div class="grid grid-cols-3 gap-4">
                                            <button onclick="selectConfidence(1)" class="bg-white text-gray-900 p-4 rounded-lg font-bold text-xl hover:bg-gray-100 transition-all">
                                                1x<br><span class="text-sm">Play it safe</span>
                                            </button>
                                            <button onclick="selectConfidence(2)" class="bg-white text-orange-600 p-4 rounded-lg font-bold text-xl hover:bg-orange-50 transition-all">
                                                2x<br><span class="text-sm">Feeling good!</span>
                                            </button>
                                            <button onclick="selectConfidence(3)" class="bg-white text-red-600 p-4 rounded-lg font-bold text-xl hover:bg-red-50 transition-all">
                                                3x<br><span class="text-sm">All in!</span>
                                            </button>
                                        </div>
                                    </div>
                                ` : ''}

                                ${state.showConfidenceBoost && !state.selectedAnswer && state.boostTiming === 'after' ? `
                                    <div class="mb-6 p-6 bg-gradient-to-r from-blue-400 to-purple-500 border-4 border-blue-600 rounded-xl shadow-2xl">
                                        <h3 class="text-3xl font-bold text-white mb-3 text-center">üéØ CONFIDENCE BOOSTER! üéØ</h3>
                                        <p class="text-white text-lg mb-4 text-center">You've seen the question and data. How confident are you?</p>
                                        <p class="text-white font-semibold mb-4 text-center">Choose your multiplier:</p>
                                        
                                        <!-- Bomb Countdown -->
                                        <div class="mb-4 bg-white/30 rounded-lg p-3">
                                            <div class="flex items-center justify-between mb-2">
                                                <span class="text-white font-bold">Time remaining: ${state.boostCountdown}s</span>
                                                <span class="text-white font-bold">${state.boostCountdown <= 5 ? '‚ö†Ô∏è HURRY!' : ''}</span>
                                            </div>
                                            <div class="relative h-8 bg-white/20 rounded-full overflow-hidden">
                                                <div class="absolute top-0 left-0 h-full bg-red-500/50 transition-all duration-1000" style="width: ${(state.boostCountdown / 20) * 100}%"></div>
                                                <div class="absolute top-1/2 -translate-y-1/2 transition-all duration-1000" style="left: ${((20 - state.boostCountdown) / 20) * 100}%">
                                                    <span class="text-3xl">${state.boostCountdown <= 3 ? 'üí•' : 'üí£'}</span>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div class="grid grid-cols-3 gap-4">
                                            <button onclick="selectConfidence(1)" class="bg-white text-gray-900 p-4 rounded-lg font-bold text-xl hover:bg-gray-100 transition-all">
                                                1x<br><span class="text-sm">Not sure</span>
                                            </button>
                                            <button onclick="selectConfidence(2)" class="bg-white text-orange-600 p-4 rounded-lg font-bold text-xl hover:bg-orange-50 transition-all">
                                                2x<br><span class="text-sm">Pretty sure!</span>
                                            </button>
                                            <button onclick="selectConfidence(3)" class="bg-white text-red-600 p-4 rounded-lg font-bold text-xl hover:bg-red-50 transition-all">
                                                3x<br><span class="text-sm">Definitely!</span>
                                            </button>
                                        </div>
                                    </div>
                                ` : ''}

                                <h3 class="font-bold text-2xl mb-4 text-purple-900">${card.question}</h3>

                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                    ${optionsHTML}
                                </div>

                                ${state.showExplanation ? `
                                    <div class="p-4 rounded-lg mb-4 ${state.isCorrect ? 'bg-green-50 border-2 border-green-500' : 'bg-red-50 border-2 border-red-500'}">
                                        ${(() => {
                                            const totalCards = difficultyLevels[state.difficulty - 1].cards;
                                            const baseReward = difficultyLevels[state.difficulty - 1].baseReward;
                                            const isLastCard = state.currentCard >= totalCards;
                                            const allCorrect = state.boostCardResults.every(r => r === true) && state.boostCardResults.length === totalCards;
                                            
                                            if (state.isCorrect) {
                                                if (state.hasUsedBoost && isLastCard) {
                                                    if (allCorrect && !state.boostLost) {
                                                        const multipliedReward = baseReward * state.confidenceMultiplier;
                                                        return `<p class="font-bold text-lg">‚úì Correct! You got ALL ${totalCards} cards correct!</p><p class="text-lg mt-2">üéØ ${state.confidenceMultiplier}x multiplier applied: <span class="text-green-700">+${multipliedReward} tokens</span> (${baseReward} base √ó ${state.confidenceMultiplier})</p>`;
                                                    } else {
                                                        return `<p class="font-bold text-lg">‚úì Correct! +${baseReward} tokens</p><p class="text-sm mt-2 text-red-600">Lost ${state.confidenceMultiplier}x multiplier from earlier incorrect answer</p>`;
                                                    }
                                                } else if (state.hasUsedBoost && !isLastCard) {
                                                    const remaining = totalCards - state.currentCard;
                                                    return `<p class="font-bold text-lg">‚úì Correct! Still eligible for ${state.confidenceMultiplier}x boost!</p><p class="text-sm mt-2">${remaining} card(s) remaining - get them all correct to earn the bonus!</p>`;
                                                } else {
                                                    return `<p class="font-bold text-lg">‚úì Correct! +${baseReward} tokens</p>`;
                                                }
                                            } else {
                                                if (state.hasUsedBoost && state.confidenceMultiplier > 1) {
                                                    return `<p class="font-bold text-lg">‚úó Wrong!</p><p class="text-sm mt-2 text-red-600">Lost ${state.confidenceMultiplier}x multiplier - no bonus tokens</p>`;
                                                } else {
                                                    return `<p class="font-bold text-lg">‚úó Wrong!</p>`;
                                                }
                                            }
                                        })()}
                                    </div>
                                    <div class="bg-blue-50 p-4 rounded-lg border-2 border-blue-300 mb-4">
                                        <h4 class="font-bold text-blue-900 mb-3">Explanation:</h4>
                                        <div class="text-gray-800">${card.explanation}</div>
                                    </div>
                                    
                                    <div class="mb-4 p-4 bg-purple-50 border-2 border-purple-300 rounded-lg">
                                        <h4 class="font-bold text-purple-900 mb-3 flex items-center gap-2">
                                            üí¨ Ask AI About This Scenario
                                        </h4>
                                        <div class="flex gap-2 mb-3">
                                            <input type="text" id="aiQuestion" value="This feature is coming soon!" 
                                                placeholder="This feature is coming soon!" 
                                                class="flex-1 p-3 border-2 border-purple-200 rounded-lg"
                                                disabled>
                                            <button disabled
                                                class="px-6 py-3 bg-gray-400 text-white rounded-lg font-semibold cursor-not-allowed">
                                                Coming Soon
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <button onclick="handleNext()" 
                                        class="w-full py-3 bg-gradient-to-r from-green-600 to-blue-600 text-white rounded-lg font-semibold text-lg">
                                        ${state.currentCard < totalCards ? `Next Card (${state.currentCard + 1} of ${totalCards})` : 'Next Scenario'}
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add event listener for AI question input
            if (state.showExplanation) {
                const aiInput = document.getElementById('aiQuestion');
                if (aiInput) {
                    aiInput.addEventListener('input', e => {
                        state.aiQuestion = e.target.value;
                    });
                }
            }
        }

        function handleLogin() {
            if (state.username.trim()) {
                state.user = {
                    name: state.username,
                    tokens: 100,
                    questionsAnswered: 0,
                    correctAnswers: 0,
                    currentStreak: 0,
                    bestStreak: 0
                };
                state.showAuth = false;
                state.showLevelSelect = true;
                render();
            }
        }

        function handleAnswer(answer) {
            // Hide confidence boost countdown once answer is selected
            if (state.showConfidenceBoost) {
                state.showConfidenceBoost = false;
                if (state.boostTimer) {
                    clearInterval(state.boostTimer);
                    state.boostTimer = null;
                }
            }
            
            state.selectedAnswer = answer;
            const card = state.currentScenarioData.cards[state.currentCard - 1];
            state.isCorrect = card.correctBase ? answer.split(' (')[0] === card.correctBase : answer === card.correct;
            state.showExplanation = true;
            
            // Track boost progress if active
            if (state.hasUsedBoost && !state.boostLost) {
                state.boostCardResults.push(state.isCorrect);
                if (!state.isCorrect) {
                    state.boostLost = true;
                }
            }
            
            render();
        }

        function handleNext() {
            const totalCards = difficultyLevels[state.difficulty - 1].cards;
            const baseReward = difficultyLevels[state.difficulty - 1].baseReward;
            
            // Determine if boost applies (only on last card of scenario)
            let multiplier = 1;
            let allCardsCorrect = false;
            
            if (state.currentCard >= totalCards && state.hasUsedBoost) {
                // Check if ALL cards were correct
                allCardsCorrect = state.boostCardResults.every(result => result === true) && state.boostCardResults.length === totalCards;
                if (allCardsCorrect && !state.boostLost) {
                    multiplier = state.confidenceMultiplier;
                }
            }
            
            const reward = state.isCorrect ? baseReward * multiplier : 0;
            
            state.user.tokens = Math.max(0, state.user.tokens + reward);
            state.user.questionsAnswered++;
            state.user.correctAnswers += state.isCorrect ? 1 : 0;
            state.user.currentStreak = state.isCorrect ? state.user.currentStreak + 1 : 0;
            
            // Update best streak
            if (state.user.currentStreak > state.user.bestStreak) {
                state.user.bestStreak = state.user.currentStreak;
            }
            
            if (state.isCorrect) {
                saveScore();
            }
            
            if (state.currentCard < totalCards) {
                state.currentCard++;
            } else {
                state.scenarioNumber++;
                state.currentCard = 1;
                state.currentScenarioData = generateScenario(state.difficulty);
                // Reset boost tracking for new scenario
                state.confidenceMultiplier = 1;
                state.hasUsedBoost = false;
                state.boostCardResults = [];
                state.boostLost = false;
                // Potentially show confidence boost for next scenario
                maybeShowConfidenceBoost();
            }
            
            state.selectedAnswer = null;
            state.showExplanation = false;
            state.isCorrect = null;
            render();
        }

        async function handleAskAI() {
            if (!state.aiQuestion || !state.aiQuestion.trim() || !state.currentScenarioData) return;
            
            state.isAskingAI = true;
            render();
            
            try {
                const card = state.currentScenarioData.cards[state.currentCard - 1];
                const dataStr = Object.entries(state.currentScenarioData.data)
                    .map(([key, value]) => key + ": " + value)
                    .join('\n');
                
                const response = await fetch("https://api.anthropic.com/v1/messages", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        model: "claude-sonnet-4-20250514",
                        max_tokens: 1000,
                        messages: [{
                            role: "user",
                            content: `You are a golf physics expert helping a student understand ball flight. Here is the current scenario data:\n\n${dataStr}\n\nCurrent Question: ${card.question}\n\nStudent's Question: ${state.aiQuestion}\n\nProvide a helpful, educational response that explains the physics concepts without directly giving away the answer. Help them understand how to think about the problem.`
                        }],
                    })
                });

                const data = await response.json();
                const aiText = data.content?.find(item => item.type === "text")?.text || "I couldn't generate a response. Please try again.";
                state.aiResponse = aiText;
            } catch (error) {
                state.aiResponse = "Sorry, I encountered an error. The AI feature requires an API key to work when self-hosted.";
            } finally {
                state.isAskingAI = false;
                render();
            }
        }

        function toggleDifficulty() {
            state.showDifficultySelector = !state.showDifficultySelector;
            render();
        }

        function changeDifficulty(level) {
            state.difficulty = parseInt(level);
            state.currentScenarioData = generateScenario(state.difficulty);
            state.currentCard = 1;
            state.scenarioNumber = 1;
            state.selectedAnswer = null;
            state.showExplanation = false;
            render();
        }

        // Initial render
        render();
    </script>
</body>
</html>
