
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Flight Master</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --augusta-green: #006747;
            --augusta-dark: #004d35;
            --masters-gold: #D4AF37;
        }
        
        body { 
            margin: 0; 
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        .hint-fade { 
            color: #9ca3af; 
            font-size: 0.875rem; 
            opacity: 0.7;
            font-style: italic;
        }
        
        .golf-bg {
            background: var(--bg-image);
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            position: relative;
            min-height: 100vh;
        }
        
        .golf-bg::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 0;
        }
        
        .golf-bg > * {
            position: relative;
            z-index: 1;
        }
        
        .shot-description {
            font-size: 0.875rem;
            color: #6b7280;
            font-style: italic;
            margin-top: 0.25rem;
        }
        
        .data-card {
            position: relative;
            cursor: help;
        }
        
        .data-card .tooltip {
            visibility: hidden;
            position: absolute;
            z-index: 100;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #1f2937;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.875rem;
            white-space: normal;
            width: 250px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .data-card:hover .tooltip {
            visibility: visible;
        }
        
        .tutorial-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .tutorial-content {
            background: white;
            border-radius: 12px;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 30px;
        }
    </style>
    <script>
        // Augusta 12th hole background for all screens
        // Green gradient fallback if image fails to load
        const augustaBackground = '/mnt/user-data/uploads/ChatGPT_Image_Jan_24__2026__07_18_56_PM.png';
        document.documentElement.style.setProperty('--bg-image', 
            `linear-gradient(135deg, #2d7a4f 0%, #1a5c3f 25%, #0f4229 50%, #1a5c3f 75%, #2d7a4f 100%), url('${augustaBackground}')`
        );
    </script>
</head>
<body>
    <div id="app"></div>
    <script>
        // VERSION INFO
        const APP_VERSION = "Updated: January 25, 2026 - 12:20 PM EST";
        
        // Simple state management
        let state = {
            user: null,
            showAuth: true,
            showLevelSelect: false,
            username: '',
            scenarioNumber: 1,
            currentCard: 1,
            selectedAnswer: null,
            showExplanation: false,
            isCorrect: null,
            difficulty: 1,
            showDifficultySelector: false,
            currentScenarioData: null,
            showConfidenceBoost: false,
            confidenceMultiplier: 1,
            hasUsedBoost: false,
            boostCountdown: 20,
            boostTimer: null,
            boostCardResults: [], // Track card results for multi-card scenarios
            boostLost: false,
            showLevelModal: false,
            showTutorial: false,
            tutorialLevel: null, // Which level's tutorial to show
            tutorialsShown: [], // Track which level tutorials have been shown
            levelPerformance: {}, // Track stats per level: { 1: { scenarios: 15, correct: 42, total: 45, recent: [3,2,3,3,2] }, ... }
            showLevelUpPromotion: false,
            promotionTargetLevel: null
        };

        const difficultyLevels = [
            { level: 1, name: "Range Rookie", description: "Learn face-to-path calculation", baseReward: 10, cards: 2, details: "Learn to calculate face-to-path angle and identify basic shot shapes. Full hints provided. Data: Club, Face, Path" },
            { level: 2, name: "Weekend Warrior", description: "Practice fundamentals", baseReward: 15, cards: 2, details: "Reinforce face-to-path calculations with shot shape recognition. 3 answer options." },
            { level: 3, name: "Club Champion", description: "Add horizontal gear effect", baseReward: 25, cards: 3, details: "NEW DATA: Impact Location (toe/heel). Learn how horizontal gear effect creates draws from heel hits and fades from toe hits. 4 answer options." },
            { level: 4, name: "Scratch Golfer", description: "Master the basics", baseReward: 40, cards: 3, details: "Solidify understanding of face-to-path, start direction, and horizontal gear effect. More extreme mishits." },
            { level: 5, name: "Mini-Tour Pro", description: "Add vertical gear effect", baseReward: 60, cards: 3, details: "NEW DATA: Vertical Impact (high/low on face). Learn how vertical position affects sidespin effectiveness. High face = more curve, low face = less curve." },
            { level: 6, name: "Korn Ferry Player", description: "Advanced concepts", baseReward: 85, cards: 3, details: "New questions: What's the PRIMARY cause? What's the NET curve direction? Hints start fading (gray text)." },
            { level: 7, name: "PGA Tour Player", description: "Lie angle affects face", baseReward: 115, cards: 3, details: "NEW DATA: Lie Angle. Learn how upright lie closes the face (ball goes left) and flat lie opens it (ball goes right). All directional hints removed." },
            { level: 8, name: "Tour Winner", description: "Wind conditions added", baseReward: 150, cards: 3, details: "NEW DATA: Wind. Learn how headwind amplifies spin, tailwind dampens it, and crosswind pushes laterally. Hypothetical questions appear. Trick scenarios (15% chance)." },
            { level: 9, name: "Major Champion", description: "Expert-level analysis", baseReward: 200, cards: 3, details: "All question types in play. Reverse calculations, shot diagnosis. 95% penalty for wrong answers." },
            { level: 10, name: "Masters Champion", description: "Ultimate challenge", baseReward: 300, cards: 3, details: "The pinnacle. All variables, trick scenarios, no hints, 6 answer options. Wrong answers cost you the full 300 tokens. Earn your green jacket!" }
        ];

        const shotShapeDescriptions = {
            "Straight": "starts on target, flies straight",
            "Push": "starts right, flies straight",
            "Pull": "starts left, flies straight",
            "Draw": "starts on target, curves left",
            "Fade": "starts on target, curves right",
            "Hook": "starts on target, curves severely left",
            "Slice": "starts on target, curves severely right",
            "Push-draw": "starts right, curves left",
            "Push-fade": "starts right, curves right",
            "Push-hook": "starts right, curves severely left",
            "Push-slice": "starts right, curves severely right",
            "Pull-draw": "starts left, curves left",
            "Pull-fade": "starts left, curves right",
            "Pull-hook": "starts left, curves severely left",
            "Pull-slice": "starts left, curves severely right"
        };
        
        function getDataTooltips(diffLevel) {
            const isHighLevel = diffLevel >= 7;
            
            if (isHighLevel) {
                // Simplified tooltips for advanced players (Level 7+)
                return {
                    "Club / Club Speed / Carry": "The club, clubhead speed, and carry distance",
                    "Club / Club Speed / Carry (after wind)": "Carry distance adjusted for wind",
                    "Club Face": "Direction the clubface points at impact",
                    "Club Path": "Direction the club is swinging",
                    "Impact Location": "Where ball strikes the face",
                    "Lie Angle": "Club's lie angle at impact",
                    "Wind": "Wind conditions affecting the shot"
                };
            } else {
                // Detailed tooltips for beginners (Level 1-6)
                return {
                    "Club / Club Speed / Carry": "The club used, clubhead speed at impact, and estimated carry distance (affected by wind at level 8+)",
                    "Club / Club Speed / Carry (after wind)": "Carry distance has been adjusted for wind effects. Headwind reduces distance, tailwind increases it.",
                    "Club Face": "Direction the clubface points at impact. Negative = left, positive = right. Controls ~75-85% of start direction.",
                    "Club Path": "Direction the club is swinging. Negative = left, positive = right. Face-to-path difference creates curve.",
                    "Impact Location": "Where ball strikes the face. Toe creates draw spin, heel creates fade spin. High on face increases sidespin, low decreases it.",
                    "Lie Angle": "Club's lie at impact. Upright closes the face, flat opens it. Effect varies by club type.",
                    "Wind": "Wind conditions affect both distance and spin. Headwind amplifies curve, tailwind reduces it. Crosswind pushes the ball laterally."
                };
            }
        }


        function generateScenario(diffLevel) {
            let isTrickScenario = false; // Track if this is a trick scenario
            
            const baseClubSpeed = { driver: 105, wood: 95, iron: 85, wedge: 75 };
            const baseCarryDistance = { driver: 250, wood: 220, iron: 165, wedge: 120 };
            const clubs = diffLevel <= 2 ? ["7 Iron"] : 
                         diffLevel <= 5 ? ["Driver", "5 Wood", "7 Iron"] :
                         ["Driver", "3 Wood", "5 Iron", "7 Iron", "PW"];
            const club = clubs[Math.floor(Math.random() * clubs.length)];
            
            const clubType = club.includes("Driver") ? "driver" : 
                             club.includes("Wood") ? "wood" : 
                             club.includes("PW") ? "wedge" : "iron";
            
            // Club-specific physics
            const clubPhysics = {
                driver: { startFaceInfluence: 0.85, curveMultiplier: 6, loft: 10, gearMultiplier: 0.6 },
                wood: { startFaceInfluence: 0.82, curveMultiplier: 5, loft: 18, gearMultiplier: 0.5 },
                iron: { startFaceInfluence: 0.75, curveMultiplier: 4, loft: 34, gearMultiplier: 0.3 },
                wedge: { startFaceInfluence: 0.70, curveMultiplier: 3, loft: 50, gearMultiplier: 0.15 }
            };
            const physics = clubPhysics[clubType];
            
            const speedVariance = diffLevel % 2 === 0 ? 15 : 10;
            
            let speed = baseClubSpeed[clubType] + (Math.random() * speedVariance - speedVariance/2);
            let carry = baseCarryDistance[clubType] + (Math.random() * (speedVariance * 2) - speedVariance);
            
            // Bell curve distribution for angles using Box-Muller transform
            // This creates a normal distribution centered at 0
            function bellCurve(min, max, stdDev) {
                // Box-Muller transform for normal distribution
                let u1 = Math.random();
                let u2 = Math.random();
                let z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                // Scale to desired std deviation and clamp to range
                let value = z * stdDev;
                return Math.max(min, Math.min(max, value));
            }
            
            // Face: bell curve with std dev of 3Â° (most shots within Â±3Â°)
            let face = bellCurve(-11, 11, 3);
            face = parseFloat(face.toFixed(1));
            
            // Path: bell curve with std dev of 3.5Â° (slightly wider than face)
            let path = bellCurve(-11, 11, 3.5);
            path = parseFloat(path.toFixed(1));
            
            let gearEffect = 0; // Will be set if impact location exists
            let impact = 0; // Horizontal impact location (toe/heel)
            let impactSide = ""; // Will be set if impact exists
            let windEffect = 0; // Will be set if wind exists
            let windDir = "";
            let impactLocationText = "";
            
            let faceDisplay, pathDisplay;
            
            // Progressive hint removal: levels 1-4 full hints, 5-6 faded, 7+ none
            if (diffLevel <= 4) {
                faceDisplay = face + "Â°" + (face > 0 ? " (right)" : face < 0 ? " (left)" : "");
                pathDisplay = path + "Â°" + (path > 0 ? " (right)" : path < 0 ? " (left)" : "");
            } else if (diffLevel <= 6) {
                // Faded hints with CSS class
                const faceHint = face > 0 ? ' <span class="hint-fade">(right)</span>' : face < 0 ? ' <span class="hint-fade">(left)</span>' : "";
                const pathHint = path > 0 ? ' <span class="hint-fade">(right)</span>' : path < 0 ? ' <span class="hint-fade">(left)</span>' : "";
                faceDisplay = face + "Â°" + faceHint;
                pathDisplay = path + "Â°" + pathHint;
            } else {
                // Levels 7-10: no hints at all
                faceDisplay = face + "Â°";
                pathDisplay = path + "Â°";
            }
            
            // Initialize carry label (will be updated if wind exists)
            let carryLabel = "Club / Club Speed / Carry";
            
            let data = {
                [carryLabel]: {
                    icon: "ðŸŒï¸",
                    label: carryLabel,
                    value: club + " â€¢ " + speed.toFixed(1) + " mph â€¢ " + Math.round(carry) + " yards"
                },
                "Club Face": {
                    icon: "ðŸŽ¯",
                    label: "Club Face",
                    value: faceDisplay
                },
                "Club Path": {
                    icon: "â†ªï¸",
                    label: "Club Path",
                    value: pathDisplay
                }
            };
            
            if (diffLevel >= 3) {
                // Trick scenarios: at high levels, occasionally create strong opposing forces
                const shouldBeTrick = diffLevel >= 8 && Math.random() < 0.15; // 15% chance at levels 8-10
                
                // Club-specific maximum impact distances (full clubface width)
                const maxImpactByClub = {
                    driver: 30,   // Â±30mm from center
                    wood: 27.5,   // Â±27.5mm from center
                    iron: 25,     // Â±25mm from center
                    wedge: 22.5   // Â±22.5mm from center
                };
                
                let maxImpact = diffLevel === 3 ? 6 : maxImpactByClub[clubType];
                
                if (shouldBeTrick) {
                    isTrickScenario = true; // Mark this as a trick scenario
                    // Force a trick scenario: strong gear effect opposing face-to-path
                    maxImpact = maxImpactByClub[clubType];
                    const faceToPath = face - path;
                    // If face-to-path is positive (fade), create strong toe hit (draw gear)
                    // If face-to-path is negative (draw), create strong heel hit (fade gear)
                    if (faceToPath > 0) {
                        impact = Math.random() * (maxImpact * 0.5) + (maxImpact * 0.5); // Strong toe hit (50-100% of max)
                    } else if (faceToPath < 0) {
                        impact = -(Math.random() * (maxImpact * 0.5) + (maxImpact * 0.5)); // Strong heel hit
                    } else {
                        impact = Math.random() * maxImpact * 2 - maxImpact; // Random if straight
                    }
                } else {
                    impact = Math.random() * maxImpact * 2 - maxImpact;
                }
                
                impactSide = impact > 0 ? "toe" : impact < 0 ? "heel" : "center";
                
                data["Impact Location"] = {
                    icon: "ðŸ“",
                    label: "Impact Location",
                    value: Math.abs(impact).toFixed(1) + "mm " + impactSide,
                    visual: null // Will be set after vertical impact is calculated
                };
                
                // Gear effect: heel creates FADE spin (negative impact = positive gear effect = fade)
                // toe creates DRAW spin (positive impact = negative gear effect = draw)
                gearEffect = impact * -physics.gearMultiplier;
                impactLocationText = Math.abs(impact).toFixed(1) + "mm " + impactSide;
            }
            
            // Vertical impact (high/low on face) added at level 5
            let verticalImpact = 0;
            let verticalGearMultiplier = 1.0;
            
            if (diffLevel >= 5) {
                // Generate vertical impact: -12mm (low) to +12mm (high)
                verticalImpact = (Math.random() * 24) - 12;
                const verticalSide = verticalImpact > 0 ? "high" : "low";
                
                // Update impact location display to include vertical
                if (diffLevel >= 3) {
                    const horizontalText = Math.abs(impact).toFixed(1) + "mm " + impactSide;
                    const verticalText = Math.abs(verticalImpact).toFixed(1) + "mm " + verticalSide;
                    data["Impact Location"].value = horizontalText + ", " + verticalText;
                }
                
                // Calculate vertical gear effect (club-specific)
                const verticalMultipliers = {
                    driver: { high: 1.20, low: 0.80 },
                    wood: { high: 1.15, low: 0.85 },
                    iron: { high: 1.10, low: 0.90 },
                    wedge: { high: 1.05, low: 0.95 }
                };
                
                const multipliers = verticalMultipliers[clubType];
                const absVertical = Math.abs(verticalImpact);
                
                if (verticalImpact > 0) {
                    // High on face: more sidespin effectiveness
                    verticalGearMultiplier = 1.0 + ((multipliers.high - 1.0) * (absVertical / 12));
                } else {
                    // Low on face: less sidespin effectiveness
                    verticalGearMultiplier = 1.0 - ((1.0 - multipliers.low) * (absVertical / 12));
                }
            } else if (diffLevel >= 3) {
                // Level 3-4: No visual needed anymore
            }
            
            // Lie Angle added at level 7
            let lieAngleAdjustment = 0;
            let originalFace = face; // Store original before lie adjustment
            let lieAngle = 0;
            
            if (diffLevel >= 7) {
                // Generate lie angle: -3Â° (flat) to +3Â° (upright)
                lieAngle = (Math.random() * 6) - 3;
                const lieType = lieAngle > 0.5 ? "upright" : lieAngle < -0.5 ? "flat" : "standard";
                
                // Display lie angle
                if (Math.abs(lieAngle) > 0.5) {
                    const lieValue = lieType === "standard" ? "Standard" : Math.abs(lieAngle).toFixed(1) + "Â° " + lieType;
                    data["Lie Angle"] = {
                        icon: "ðŸ“",
                        label: "Lie Angle",
                        value: lieValue
                    };
                    
                    // Lie angle affects face angle: upright closes face (left), flat opens face (right)
                    // Club-specific multipliers (realistic physics)
                    const lieMultipliers = {
                        driver: 0.3,  // Long clubs less affected
                        wood: 0.4,
                        iron: 0.5,
                        wedge: 0.7    // Short clubs more affected
                    };
                    const lieMultiplier = lieMultipliers[clubType];
                    
                    // CRITICAL: Upright (positive) = closes face (negative adjustment)
                    // Flat (negative) = opens face (positive adjustment)
                    lieAngleAdjustment = lieAngle * -lieMultiplier;
                    face = face + lieAngleAdjustment;
                }
            }
            
            let windSpeedMPH = 0;
            let windMultiplier = 1.0; // How wind affects spin/curve
            let carryAdjustment = 0; // How wind affects distance
            
            if (diffLevel >= 8) {
                // Bell curve distribution: mean ~7 MPH, std dev ~5, capped at 25
                const bellCurve = () => {
                    const u1 = Math.random();
                    const u2 = Math.random();
                    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    return z * 5 + 7; // std dev 5, mean 7
                };
                windSpeedMPH = Math.max(0, Math.min(25, Math.round(bellCurve())));
                
                const windDirs = ["Headwind", "Tailwind", "Left-to-Right", "Right-to-Left"];
                windDir = windDirs[Math.floor(Math.random() * windDirs.length)];
                
                // Only show wind card if there's actual wind
                if (windSpeedMPH > 0) {
                    data["Wind"] = {
                        icon: "ðŸ’¨",
                        label: "Wind",
                        value: windSpeedMPH + " mph " + windDir
                    };
                }
                
                // Wind physics
                if (windSpeedMPH > 0) {
                    if (windDir === "Headwind") {
                        carryAdjustment = -windSpeedMPH * 2; // Headwind hurts more
                        windMultiplier = 1.0 + (windSpeedMPH / 100); // Amplifies spin/curve by ~20-30% at strong wind
                    } else if (windDir === "Tailwind") {
                        carryAdjustment = windSpeedMPH * 1; // Tailwind helps less
                        windMultiplier = 1.0 - (windSpeedMPH / 150); // Dampens spin/curve by ~15-20% at strong wind
                    } else {
                        // Crosswind: lateral push based on speed tier
                        const carryInTens = carry / 10;
                        let yardsPerTen;
                        if (windSpeedMPH <= 10) yardsPerTen = 0.5; // Light
                        else if (windSpeedMPH <= 15) yardsPerTen = 0.75; // Moderate
                        else yardsPerTen = 1.0; // Strong
                        
                        windEffect = (windDir === "Left-to-Right" ? 1 : -1) * yardsPerTen * carryInTens;
                        carryAdjustment = -windSpeedMPH * 0.1; // Slight drag from crosswind
                    }
                }
            }
            
            // Apply carry adjustment
            carry = Math.round(carry + carryAdjustment);
            
            // Update carry label if wind affected distance
            if (windSpeedMPH > 0 && carryAdjustment !== 0) {
                carryLabel = "Club / Club Speed / Carry (after wind)";
            }
            
            const faceToPath = face - path + gearEffect;
            const startDir = face > 0 ? "right" : face < 0 ? "left" : "straight";
            
            // Determine shape based on tighter thresholds
            const absFTP = Math.abs(faceToPath);
            const curveType = absFTP <= 0.5 ? "straight" : absFTP <= 3.0 ? "moderate" : absFTP <= 6.0 ? "heavy" : "extreme";
            const startType = Math.abs(face) <= 1 ? "straight" : face > 1 ? "push" : "pull";
            const isDrawCurve = faceToPath < 0;
            
            let shape = "Straight";
            let shapeDesc = "on target, no curve";
            
            if (curveType !== "straight") {
                const curveNames = {
                    moderate: isDrawCurve ? ["Draw", "curves moderately left, consistent predictable shape"] : ["Fade", "curves moderately right, consistent predictable shape"],
                    heavy: isDrawCurve ? ["Draw", "curves moderately left, consistent predictable shape"] : ["Fade", "curves moderately right, consistent predictable shape"],
                    extreme: isDrawCurve ? ["Hook", "curves severely left, hard to control"] : ["Slice", "curves severely right, hard to control"]
                };
                
                if (startType === "straight") {
                    [shape, shapeDesc] = curveNames[curveType];
                } else if (startType === "push") {
                    if (curveType === "moderate") [shape, shapeDesc] = isDrawCurve ? ["Push-draw", "starts right, curves back left toward target"] : ["Push-fade", "starts right, curves further right"];
                    else if (curveType === "heavy") [shape, shapeDesc] = isDrawCurve ? ["Push-draw", "starts right, curves back left toward target"] : ["Push-fade", "starts right, curves further right"];
                    else [shape, shapeDesc] = isDrawCurve ? ["Push-hook", "starts right, curves severely back left"] : ["Push-slice", "starts right, curves strongly further right"];
                } else {
                    if (curveType === "moderate" || curveType === "heavy") [shape, shapeDesc] = isDrawCurve ? ["Pull-draw", "starts left, curves further left"] : ["Pull-fade", "starts left, curves back right toward target"];
                    else [shape, shapeDesc] = isDrawCurve ? ["Pull-hook", "starts left, curves severely further left"] : ["Pull-slice", "starts left, curves strongly back right"];
                }
            } else {
                if (startType === "push") [shape, shapeDesc] = ["Push", "starts right of target, flies straight right"];
                else if (startType === "pull") [shape, shapeDesc] = ["Pull", "starts left of target, flies straight left"];
            }

            const cards = [];
            const baseFaceToPath = face - path;
            
            // LEVEL-BASED CARD GENERATION
            if (diffLevel <= 2) {
                // Level 1: 2 questions - Face-to-path + Shot shape
                // Level 2: 3 questions - Face-to-path + Curve direction + Shot shape
                cards.push(generateFaceToPathQuestion(face, path, diffLevel));
                
                // Level 2: Add curve direction question
                if (diffLevel === 2) {
                    cards.push(generateCurveDirectionQuestion(baseFaceToPath, diffLevel));
                }
                
                // Then shot shape question
                const allShapes = ["Straight", "Push", "Pull", "Draw", "Fade", "Hook", "Slice", "Push-draw", "Push-fade", "Push-hook", "Push-slice", "Pull-hook", "Pull-fade", "Pull-slice"];
                const numWrongOptions = 2; // 3 total
                const wrongShapes = allShapes.filter(s => s !== shape).sort(() => Math.random() - 0.5).slice(0, numWrongOptions);
                const options = [shape, ...wrongShapes].sort(() => Math.random() - 0.5);
                
                let explanationParts = [];
                explanationParts.push(`<strong>Club:</strong> ${club} (${physics.loft}Â° loft)`);
                explanationParts.push(`<strong>Face:</strong> ${face}Â°`);
                explanationParts.push(`<strong>Path:</strong> ${path}Â°`);
                explanationParts.push(`<strong>Face-to-path:</strong> ${baseFaceToPath.toFixed(1)}Â°`);
                if (gearEffect !== 0) {
                    const gearDir = gearEffect > 0 ? "fade" : "draw";
                    const gearRelation = (gearEffect > 0 && baseFaceToPath > 0) || (gearEffect < 0 && baseFaceToPath < 0) ? "additional" : "opposing";
                    const highlightClass = gearRelation === "opposing" ? ' style="color: #dc2626; font-weight: bold;"' : '';
                    const warningIcon = gearRelation === "opposing" ? "âš ï¸ " : "";
                    explanationParts.push(`<strong${highlightClass}>${warningIcon}Gear effect (${gearRelation}):</strong> ${impactLocationText} = ${Math.abs(gearEffect).toFixed(1)}Â° ${gearDir} spin`);
                    explanationParts.push(`<strong>Total face-to-path:</strong> ${faceToPath.toFixed(1)}Â° (with gear effect)`);
                }
                explanationParts.push(`<strong>Result:</strong> ${shape} - ${shapeDesc}`);
                
                cards.push({
                    question: "What will be the shot shape?",
                    options: options,
                    correct: shape,
                    correctBase: shape,
                    explanation: '<div class="space-y-1">' + explanationParts.map(p => '<div>' + p + '</div>').join('') + '</div>'
                });
                
            } else if (diffLevel <= 4) {
                // Level 3-4: face-to-path + start direction + shot shape
                cards.push(generateFaceToPathQuestion(face, path, diffLevel));
                
                cards.push({
                    question: "Will the ball start left or right of the target?",
                    options: ["Left of target", "Right of target", "Straight at target"],
                    correct: face < -0.5 ? "Left of target" : face > 0.5 ? "Right of target" : "Straight at target",
                    explanation: lieAngleAdjustment !== 0 
                        ? `<div><strong>Original face:</strong> ${originalFace.toFixed(1)}Â°</div><div><strong>Lie adjustment:</strong> ${lieAngleAdjustment.toFixed(1)}Â°</div><div><strong>Effective face:</strong> ${face.toFixed(1)}Â°</div><div><strong>Club:</strong> ${club} (${Math.round(physics.startFaceInfluence * 100)}% face influence)</div><div>The ball starts <strong>${startDir}</strong> because face angle controls ${Math.round(physics.startFaceInfluence * 100)}% of initial direction for this club.</div>`
                        : `<div><strong>Face angle:</strong> ${face.toFixed(1)}Â°</div><div><strong>Club:</strong> ${club} (${Math.round(physics.startFaceInfluence * 100)}% face influence)</div><div>The ball starts <strong>${startDir}</strong> because face angle controls ${Math.round(physics.startFaceInfluence * 100)}% of initial direction for this club.</div>`
                });
                
                // Shot shape
                const allShapes = ["Straight", "Push", "Pull", "Draw", "Fade", "Hook", "Slice", "Push-draw", "Push-fade", "Push-hook", "Push-slice", "Pull-hook", "Pull-fade", "Pull-slice"];
                const numWrongOptions = 3; // 4 total
                const wrongShapes = allShapes.filter(s => s !== shape).sort(() => Math.random() - 0.5).slice(0, numWrongOptions);
                const options = [shape, ...wrongShapes].sort(() => Math.random() - 0.5);
                
                let explanationParts = [];
                explanationParts.push(`<strong>Club:</strong> ${club} (${physics.loft}Â° loft)`);
                explanationParts.push(`<strong>Face:</strong> ${face}Â°`);
                explanationParts.push(`<strong>Path:</strong> ${path}Â°`);
                explanationParts.push(`<strong>Face-to-path:</strong> ${baseFaceToPath.toFixed(1)}Â°`);
                if (gearEffect !== 0) {
                    const gearDir = gearEffect > 0 ? "fade" : "draw";
                    const gearRelation = (gearEffect > 0 && baseFaceToPath > 0) || (gearEffect < 0 && baseFaceToPath < 0) ? "additional" : "opposing";
                    const highlightClass = gearRelation === "opposing" ? ' style="color: #dc2626; font-weight: bold;"' : '';
                    const warningIcon = gearRelation === "opposing" ? "âš ï¸ " : "";
                    explanationParts.push(`<strong${highlightClass}>${warningIcon}Gear effect (${gearRelation}):</strong> ${impactLocationText} = ${Math.abs(gearEffect).toFixed(1)}Â° ${gearDir} spin`);
                    explanationParts.push(`<strong>Total face-to-path:</strong> ${faceToPath.toFixed(1)}Â° (with gear effect)`);
                }
                explanationParts.push(`<strong>Result:</strong> ${shape} - ${shapeDesc}`);
                
                cards.push({
                    question: "What will be the shot shape?",
                    options: options,
                    correct: shape,
                    correctBase: shape,
                    explanation: '<div class="space-y-1">' + explanationParts.map(p => '<div>' + p + '</div>').join('') + '</div>'
                });
                
            } else {
                // Level 5+: Mix of questions, progressively harder
                const questionPool = [];
                
                // Organize questions by priority to avoid spoilers
                let basicQuestions = []; // Safe questions that don't reveal answers
                const spoilerQuestions = []; // Questions that reveal calculation results
                const hypotheticalQuestions = []; // What-if questions (come after knowing original result)
                
                // Shot shape (always available - basic question)
                const allShapes = ["Straight", "Push", "Pull", "Draw", "Fade", "Hook", "Slice", "Push-draw", "Push-fade", "Push-hook", "Push-slice", "Pull-hook", "Pull-fade", "Pull-slice"];
                
                // Determine number of options: 1-3=3, 4-6=4, 7-9=5, 10=6
                let numWrongOptions;
                if (diffLevel <= 3) numWrongOptions = 2; // 3 total options
                else if (diffLevel <= 6) numWrongOptions = 3; // 4 total options
                else if (diffLevel <= 9) numWrongOptions = 4; // 5 total options
                else numWrongOptions = 5; // 6 total options (level 10)
                
                const wrongShapes = allShapes.filter(s => s !== shape).sort(() => Math.random() - 0.5).slice(0, numWrongOptions);
                const options = [shape, ...wrongShapes].sort(() => Math.random() - 0.5);
                
                let explanationParts = [];
                explanationParts.push(`<strong>Club:</strong> ${club} (${physics.loft}Â° loft)`);
                explanationParts.push(`<strong>Face:</strong> ${face}Â°`);
                explanationParts.push(`<strong>Path:</strong> ${path}Â°`);
                explanationParts.push(`<strong>Face-to-path:</strong> ${baseFaceToPath.toFixed(1)}Â°`);
                if (gearEffect !== 0) {
                    const gearDir = gearEffect > 0 ? "fade" : "draw";
                    const gearRelation = (gearEffect > 0 && baseFaceToPath > 0) || (gearEffect < 0 && baseFaceToPath < 0) ? "additional" : "opposing";
                    const highlightClass = gearRelation === "opposing" ? ' style="color: #dc2626; font-weight: bold;"' : '';
                    const warningIcon = gearRelation === "opposing" ? "âš ï¸ " : "";
                    explanationParts.push(`<strong${highlightClass}>${warningIcon}Gear effect (${gearRelation}):</strong> ${impactLocationText} = ${Math.abs(gearEffect).toFixed(1)}Â° ${gearDir} spin`);
                    explanationParts.push(`<strong>Total face-to-path:</strong> ${faceToPath.toFixed(1)}Â° (with gear effect)`);
                }
                explanationParts.push(`<strong>Result:</strong> ${shape} - ${shapeDesc}`);
                
                basicQuestions.push({
                    question: "What will be the shot shape?",
                    options: options,
                    correct: shape,
                    correctBase: shape,
                    explanation: '<div class="space-y-1">' + explanationParts.map(p => '<div>' + p + '</div>').join('') + '</div>'
                });
                
                // Start direction (basic - just left/right, no distance) - Level 5+
                basicQuestions.push({
                    question: "Will the ball start left or right of the target?",
                    options: ["Left of target", "Right of target", "Straight at target"],
                    correct: face < -0.5 ? "Left of target" : face > 0.5 ? "Right of target" : "Straight at target",
                    explanation: lieAngleAdjustment !== 0 
                        ? `<div><strong>Original face:</strong> ${originalFace.toFixed(1)}Â°</div><div><strong>Lie adjustment:</strong> ${lieAngleAdjustment.toFixed(1)}Â°</div><div><strong>Effective face:</strong> ${face.toFixed(1)}Â°</div><div><strong>Club:</strong> ${club} (${Math.round(physics.startFaceInfluence * 100)}% face influence)</div><div>The ball starts <strong>${startDir}</strong> because face angle controls ${Math.round(physics.startFaceInfluence * 100)}% of initial direction for this club.</div>`
                        : `<div><strong>Face angle:</strong> ${face.toFixed(1)}Â°</div><div><strong>Club:</strong> ${club} (${Math.round(physics.startFaceInfluence * 100)}% face influence)</div><div>The ball starts <strong>${startDir}</strong> because face angle controls ${Math.round(physics.startFaceInfluence * 100)}% of initial direction for this club.</div>`
                });
                
                // Start position in yards (SPOILER - reveals direction) - Level 5+
                spoilerQuestions.push(generateStartPositionQuestion(face, physics, diffLevel));
                
                // Advanced questions for level 6+
                if (diffLevel >= 6) {
                    spoilerQuestions.push(generatePrimaryCauseQuestion(face, path, gearEffect, windEffect, diffLevel));
                    spoilerQuestions.push(generateNetCurveQuestion(baseFaceToPath, gearEffect, windEffect, diffLevel));
                }
                
                // Level 5: Add gear effect help/hurt question if gear effect exists
                if (diffLevel >= 5 && gearEffect !== 0 && Math.abs(baseFaceToPath) > 1) {
                    basicQuestions.push(generateGearHelpHurtQuestion(gearEffect, baseFaceToPath, impactLocationText, diffLevel));
                }
                
                // Level 5-6: Add face percentage and curve comparison questions
                if (diffLevel >= 5 && diffLevel <= 6) {
                    basicQuestions.push(generateFacePercentageQuestion(club, physics, diffLevel));
                    if (gearEffect !== 0 && Math.abs(baseFaceToPath) > 1) {
                        basicQuestions.push(generateCurveComparisonQuestion(baseFaceToPath, gearEffect, clubType, diffLevel));
                    }
                }
                
                // Level 7: Add lie angle questions
                if (diffLevel >= 7 && Math.abs(lieAngle) > 0.5) {
                    basicQuestions.push(generateLieEffectDirectionQuestion(lieAngle, diffLevel));
                    spoilerQuestions.push(generateStandardLieHypotheticalQuestion(face, originalFace, lieAngleAdjustment, faceContribution, curveContribution, windEffect, diffLevel));
                }
                
                // Advanced questions for level 7-10
                if (diffLevel >= 7) {
                    spoilerQuestions.push(generateLeastImpactQuestion(face, path, gearEffect, windEffect, diffLevel));
                }
                
                if (diffLevel >= 8) {
                    // Will add hypothetical and vertical impact questions after we calculate values below
                }
                
                // Offline distance (Level 5+) - always include
                // Calculate components with club-specific physics
                const faceContribution = face * 3; // Keep sign - positive = right, negative = left
                const baseCurveContribution = baseFaceToPath * physics.curveMultiplier * windMultiplier * verticalGearMultiplier; // Wind and vertical impact affect spin/curve
                const gearContribution = gearEffect * physics.curveMultiplier * windMultiplier * verticalGearMultiplier; // Gear effect also affected by wind and vertical impact
                const curveContribution = baseCurveContribution + gearContribution; // Total curve
                
                // Add hypothetical question and vertical impact question (Level 8+)
                if (diffLevel >= 8) {
                    // Wind amplify/dampen and worst-case questions
                    if (windSpeedMPH > 0 && Math.abs(baseFaceToPath) > 1) {
                        basicQuestions.push(generateWindAmplifyDampenQuestion(windDir, baseFaceToPath, diffLevel));
                        basicQuestions.push(generateWorstWindScenarioQuestion(baseFaceToPath, diffLevel));
                    }
                    
                    // Hypothetical question
                    hypotheticalQuestions.push(generateHypotheticalQuestion(face, path, faceContribution, curveContribution, windEffect, diffLevel, physics.curveMultiplier, windMultiplier, verticalGearMultiplier, gearEffect));
                    
                    // Add vertical impact curve question if significant vertical impact
                    if (Math.abs(verticalImpact) > 2 && Math.abs(baseFaceToPath) > 1) {
                        basicQuestions.push(generateVerticalImpactCurveQuestion(verticalImpact, verticalGearMultiplier, baseFaceToPath, diffLevel));
                    }
                }
                
                // Level 9-10: Advanced strategic questions
                if (diffLevel >= 9) {
                    spoilerQuestions.push(generateOpposingForcesQuestion(face, path, gearEffect, windEffect, baseFaceToPath, diffLevel));
                    spoilerQuestions.push(generateBestVariableQuestion(face, path, gearEffect, windEffect, diffLevel));
                    spoilerQuestions.push(generateRankByImpactQuestion(face, path, gearEffect, windEffect, diffLevel));
                }
                
                // Net offline is: where it starts (face) + how much it curves (total)
                const netOffline = faceContribution + curveContribution + windEffect;
                const offlineYards = Math.abs(netOffline);
                const roundedYards = Math.round(offlineYards);
                const offlineDir = netOffline > 0 ? "right" : "left";
                
                let opts, corr;
                
                if (diffLevel <= 6) {
                    // 7-yard ranges
                    opts = [
                        `0-6 yards ${offlineDir}`,
                        `7-13 yards ${offlineDir}`,
                        `14-20 yards ${offlineDir}`,
                        `21-27 yards ${offlineDir}`,
                        `28-34 yards ${offlineDir}`,
                        `35+ yards ${offlineDir}`
                    ];
                    corr = roundedYards <= 6 ? opts[0] : roundedYards <= 13 ? opts[1] : roundedYards <= 20 ? opts[2] : roundedYards <= 27 ? opts[3] : roundedYards <= 34 ? opts[4] : opts[5];
                } else if (diffLevel <= 8) {
                    // 5-yard ranges
                    opts = [
                        `0-4 yards ${offlineDir}`,
                        `5-9 yards ${offlineDir}`,
                        `10-14 yards ${offlineDir}`,
                        `15-19 yards ${offlineDir}`,
                        `20-24 yards ${offlineDir}`,
                        `25+ yards ${offlineDir}`
                    ];
                    corr = roundedYards <= 4 ? opts[0] : roundedYards <= 9 ? opts[1] : roundedYards <= 14 ? opts[2] : roundedYards <= 19 ? opts[3] : roundedYards <= 24 ? opts[4] : opts[5];
                } else {
                    // 3-yard ranges for level 9-10
                    opts = [
                        `0-2 yards ${offlineDir}`,
                        `3-5 yards ${offlineDir}`,
                        `6-8 yards ${offlineDir}`,
                        `9-11 yards ${offlineDir}`,
                        `12-14 yards ${offlineDir}`,
                        `15+ yards ${offlineDir}`
                    ];
                    corr = roundedYards <= 2 ? opts[0] : roundedYards <= 5 ? opts[1] : roundedYards <= 8 ? opts[2] : roundedYards <= 11 ? opts[3] : roundedYards <= 14 ? opts[4] : opts[5];
                }
                
                // Build detailed calculation explanation
                // baseFaceToPath already calculated above
                let calcParts = [];
                
                // Show start position from face with lie angle adjustment if applicable
                const faceDir = faceContribution > 0 ? "right" : "left";
                const faceYards = Math.abs(faceContribution);
                
                if (lieAngleAdjustment !== 0) {
                    // Show lie angle adjustment with club-specific multiplier
                    const lieDir = lieAngle > 0 ? "upright" : "flat";
                    const lieMultipliers = {
                        driver: 0.3,
                        wood: 0.4,
                        iron: 0.5,
                        wedge: 0.7
                    };
                    const lieMultiplier = lieMultipliers[clubType];
                    const adjustmentText = lieAngleAdjustment > 0 ? "+" + lieAngleAdjustment.toFixed(1) : lieAngleAdjustment.toFixed(1);
                    calcParts.push(`<strong>Lie angle adjustment:</strong> ${Math.abs(lieAngle).toFixed(1)}Â° ${lieDir} Ã— ${lieMultiplier} = ${adjustmentText}Â°`);
                    calcParts.push(`<strong>Effective face:</strong> ${originalFace.toFixed(1)}Â° ${adjustmentText}Â° = ${face.toFixed(1)}Â°`);
                }
                
                calcParts.push(`<strong>Start direction (face):</strong> ${face.toFixed(1)}Â° Ã— 3 = ${faceYards.toFixed(1)} yards ${faceDir}`);
                
                // Show base curve from face-to-path (keep precision)
                const baseFTPDir = baseFaceToPath < 0 ? "draw" : "fade";
                const baseFTPYards = Math.abs(baseCurveContribution);
                const baseFTPSign = baseFaceToPath < 0 ? "left" : "right";
                calcParts.push(`<strong>Face-to-path curve:</strong> ${baseFaceToPath.toFixed(1)}Â° ${baseFTPDir} = ${baseFTPYards.toFixed(1)} yards ${baseFTPSign}`);
                
                // Show gear effect if present (keep precision)
                if (gearEffect !== 0) {
                    const gearDir = gearEffect > 0 ? "fade" : "draw";
                    const gearYards = Math.abs(gearContribution);
                    const gearSign = gearEffect > 0 ? "right" : "left";
                    const gearRelation = (gearEffect > 0 && baseFaceToPath > 0) || (gearEffect < 0 && baseFaceToPath < 0) ? "additional" : "opposing";
                    const highlightClass = gearRelation === "opposing" ? ' style="color: #dc2626; font-weight: bold;"' : '';
                    const warningIcon = gearRelation === "opposing" ? "âš ï¸ " : "";
                    calcParts.push(`<strong${highlightClass}>${warningIcon}Gear effect (${gearRelation}):</strong> ${impactLocationText} creates ${Math.abs(gearEffect).toFixed(1)}Â° ${gearDir} spin = ${gearYards.toFixed(1)} yards ${gearSign}`);
                }
                
                // Show wind if present (keep precision)
                if (windEffect !== 0) {
                    const windSign = windEffect > 0 ? "right" : "left";
                    const windYards = Math.abs(windEffect);
                    calcParts.push(`<strong>Wind:</strong> ${windDir} = ${windYards.toFixed(1)} yards ${windSign}`);
                }
                
                // Show net calculation with ALL THREE components separately
                let netCalcParts = [];
                netCalcParts.push(`${faceContribution > 0 ? '+' : ''}${faceContribution.toFixed(1)} ${faceContribution > 0 ? 'right' : 'left'}`);
                netCalcParts.push(`${baseCurveContribution > 0 ? '+' : ''}${baseCurveContribution.toFixed(1)} ${baseCurveContribution > 0 ? 'right' : 'left'}`);
                
                if (gearEffect !== 0) {
                    netCalcParts.push(`${gearContribution > 0 ? '+' : ''}${gearContribution.toFixed(1)} ${gearContribution > 0 ? 'right' : 'left'}`);
                }
                
                if (windEffect !== 0) {
                    netCalcParts.push(`${windEffect > 0 ? '+' : ''}${windEffect.toFixed(1)} ${windEffect > 0 ? 'right' : 'left'}`);
                }
                
                const netCalc = netCalcParts.join(' ') + ` = ${netOffline.toFixed(1)} yards`;
                
                calcParts.push(`<strong>Net calculation:</strong> ${netCalc}`);
                calcParts.push(`<strong>Final result:</strong> ${roundedYards} yards ${offlineDir}`);
                
                // Separate the offline distance question (always last to avoid spoilers)
                const offlineQuestion = {
                    question: "How far offline will the ball finish from the target?",
                    options: opts,
                    correct: corr,
                    explanation: '<div class="space-y-1">' + calcParts.map(p => '<div>' + p + '</div>').join('') + '</div>'
                };
                
                // Level 7+: Filter out obvious questions to increase challenge
                if (diffLevel >= 7) {
                    basicQuestions = basicQuestions.filter(q => {
                        // Skip "start direction" if face angle is too obvious (|face| > 2Â°)
                        if (q.question.includes("start left or right") && Math.abs(face) > 2) {
                            return false;
                        }
                        
                        // Skip basic "shot shape" if no competing forces (gear effect not opposing face-to-path)
                        if (q.question === "What will be the shot shape?") {
                            const hasCompetingForces = gearEffect !== 0 && 
                                ((gearEffect > 0 && baseFaceToPath < 0) || (gearEffect < 0 && baseFaceToPath > 0));
                            if (!hasCompetingForces && Math.abs(baseFaceToPath) > 3) {
                                return false; // Too obvious - strong face-to-path with no opposition
                            }
                        }
                        
                        return true; // Keep all other questions
                    });
                }
                
                // Select questions from pools in proper order: basic â†’ spoiler â†’ hypothetical â†’ offline distance
                const numCards = difficultyLevels[diffLevel - 1].cards;
                
                // Strategy: Fill cards in priority order, but ensure offline distance is always last
                // and hypothetical (if any) is second-to-last
                
                const hasHypothetical = hypotheticalQuestions.length > 0;
                const availableSlots = hasHypothetical ? numCards - 2 : numCards - 1; // Reserve last slot for offline, second-to-last for hypothetical
                
                // Combine basic and spoiler questions, randomize, and take what we need
                const nonHypotheticalQuestions = [...basicQuestions, ...spoilerQuestions];
                const selectedQuestions = nonHypotheticalQuestions.sort(() => Math.random() - 0.5).slice(0, availableSlots);
                selectedQuestions.forEach(q => cards.push(q));
                
                // Add hypothetical question second-to-last (if exists)
                if (hasHypothetical) {
                    cards.push(hypotheticalQuestions[0]);
                }
                
                // Always add offline distance question last (it reveals the full calculation)
                cards.push(offlineQuestion);
            }
            
            return { data, cards, isTrickScenario };
        }

        function getShapeDesc(name) {
            const descs = {
                "Straight": "starts on target, flies straight",
                "Push": "starts right, flies straight",
                "Pull": "starts left, flies straight",
                "Draw": "starts on target, curves left",
                "Fade": "starts on target, curves right",
                "Hook": "starts on target, curves severely left",
                "Slice": "starts on target, curves severely right",
                "Push-draw": "starts right, curves left",
                "Push-fade": "starts right, curves right",
                "Push-hook": "starts right, curves severely left",
                "Push-slice": "starts right, curves severely right",
                "Pull-draw": "starts left, curves left",
                "Pull-fade": "starts left, curves right",
                "Pull-hook": "starts left, curves severely left",
                "Pull-slice": "starts left, curves severely right"
            };
            return descs[name] || "";
        }


        function generateFaceToPathQuestion(face, path, diffLevel) {
            const correctAnswer = face - path;
            const numOptions = diffLevel <= 3 ? 3 : diffLevel <= 6 ? 4 : diffLevel <= 9 ? 5 : 6;
            
            // Generate wrong answers nearby the correct one
            let options = [correctAnswer];
            const possibleWrong = [
                correctAnswer + 1, correctAnswer - 1,
                correctAnswer + 2, correctAnswer - 2,
                correctAnswer + 3, correctAnswer - 3,
                face + path, // Common mistake: adding instead of subtracting
                path - face  // Common mistake: reversing the subtraction
            ].filter(val => val !== correctAnswer);
            
            // Shuffle and take needed number of wrong answers
            const wrongAnswers = possibleWrong.sort(() => Math.random() - 0.5).slice(0, numOptions - 1);
            options.push(...wrongAnswers);
            options = options.sort(() => Math.random() - 0.5);
            
            return {
                question: "What is the face-to-path angle?",
                options: options.map(o => o.toFixed(1) + "Â°"),
                correct: correctAnswer.toFixed(1) + "Â°",
                explanation: `<div><strong>Calculation:</strong> Face-to-path = Face - Path</div><div>${face.toFixed(1)}Â° - (${path.toFixed(1)}Â°) = ${correctAnswer.toFixed(1)}Â°</div>`
            };
        }

        function generateStartPositionQuestion(face, physics, diffLevel) {
            // Ball starts approximately 3 yards per degree of face angle
            const startYards = face * 3;
            const numOptions = diffLevel <= 3 ? 3 : diffLevel <= 6 ? 4 : diffLevel <= 9 ? 5 : 6;
            
            // Create ranges
            let correctRange;
            if (Math.abs(startYards) <= 2) {
                correctRange = "Straight at target";
            } else if (startYards > 0) {
                if (startYards <= 5) correctRange = "0-2 yards right";
                else if (startYards <= 8) correctRange = "3-5 yards right";
                else if (startYards <= 12) correctRange = "6-8 yards right";
                else correctRange = "9+ yards right";
            } else {
                if (startYards >= -5) correctRange = "0-2 yards left";
                else if (startYards >= -8) correctRange = "3-5 yards left";
                else if (startYards >= -12) correctRange = "6-8 yards left";
                else correctRange = "9+ yards left";
            }
            
            const allOptions = [
                "Straight at target",
                "0-2 yards right", "3-5 yards right", "6-8 yards right", "9+ yards right",
                "0-2 yards left", "3-5 yards left", "6-8 yards left", "9+ yards left"
            ];
            
            // Get wrong answers
            const wrongOptions = allOptions.filter(o => o !== correctRange).sort(() => Math.random() - 0.5).slice(0, numOptions - 1);
            const options = [correctRange, ...wrongOptions].sort(() => Math.random() - 0.5);
            
            return {
                question: "Where will the ball start?",
                options: options,
                correct: correctRange,
                explanation: `<div><strong>Face angle:</strong> ${face.toFixed(1)}Â°</div><div><strong>Start distance:</strong> ${Math.abs(startYards).toFixed(1)} yards ${startYards > 0 ? 'right' : 'left'}</div><div>Face angle controls ${Math.round(physics.startFaceInfluence * 100)}% of start direction (~3 yards per degree)</div>`
            };
        }

        function generatePrimaryCauseQuestion(face, path, gearEffect, windEffect, diffLevel) {
            const baseFaceToPath = face - path;
            const faceContribution = Math.abs(face * 3);
            const pathContribution = Math.abs(baseFaceToPath * 5);
            const gearContribution = Math.abs(gearEffect * 5);
            const windContribution = Math.abs(windEffect);
            
            // Find primary cause
            const causes = [
                { name: "Face angle", value: faceContribution },
                { name: "Face-to-path", value: pathContribution },
                { name: "Gear effect", value: gearContribution },
                { name: "Wind", value: windContribution }
            ];
            causes.sort((a, b) => b.value - a.value);
            
            const numOptions = diffLevel <= 9 ? 5 : 6;
            const options = causes.slice(0, numOptions).map(c => c.name).sort(() => Math.random() - 0.5);
            
            return {
                question: "What is the PRIMARY cause of the ball's final position?",
                options: options,
                correct: causes[0].name,
                explanation: `<div><strong>${causes[0].name}</strong> has the biggest impact with ~${Math.round(causes[0].value)} yards of influence</div><div class="text-sm text-gray-600 mt-2">Others: ${causes.slice(1).map(c => c.name + ' ~' + Math.round(c.value) + 'yds').join(', ')}</div>`
            };
        }

        function generateNetCurveQuestion(baseFaceToPath, gearEffect, windEffect, diffLevel) {
            const totalCurve = baseFaceToPath + gearEffect + (windEffect / 5); // Wind has less effect on curve
            const netDirection = totalCurve < -0.5 ? "Draw (left)" : totalCurve > 0.5 ? "Fade (right)" : "Straight";
            
            const numOptions = diffLevel <= 9 ? 5 : 6;
            const allOptions = ["Draw (left)", "Fade (right)", "Straight", "Hook (left)", "Slice (right)"];
            const wrongOptions = allOptions.filter(o => o !== netDirection).sort(() => Math.random() - 0.5).slice(0, numOptions - 1);
            const options = [netDirection, ...wrongOptions].sort(() => Math.random() - 0.5);
            
            return {
                question: "After accounting for ALL factors, will the ball curve left or right?",
                options: options,
                correct: netDirection,
                explanation: `<div><strong>Base face-to-path:</strong> ${baseFaceToPath.toFixed(1)}Â°</div><div><strong>Gear effect:</strong> ${gearEffect > 0 ? '+' : ''}${gearEffect.toFixed(1)}Â°</div><div><strong>Wind influence:</strong> ${(windEffect / 5).toFixed(1)}Â°</div><div class="mt-2"><strong>Net curve:</strong> ${totalCurve.toFixed(1)}Â° = ${netDirection}</div>`
            };
        }

        function generateHypotheticalQuestion(face, path, faceContribution, curveContribution, windEffect, diffLevel, curveMultiplier, windMultiplier, verticalGearMultiplier, gearEffect) {
            // What if face was 2Â° more closed?
            const newFace = face - 2;
            const newFaceContribution = newFace * 3;
            
            // CRITICAL: Recalculate curve with new face-to-path
            const newFaceToPath = newFace - path;
            const newBaseCurveContribution = newFaceToPath * curveMultiplier * windMultiplier * verticalGearMultiplier;
            const newGearContribution = gearEffect * curveMultiplier * windMultiplier * verticalGearMultiplier; // Gear stays same
            const newCurveContribution = newBaseCurveContribution + newGearContribution;
            
            const newNetOffline = newFaceContribution + newCurveContribution + windEffect;
            const newRoundedYards = Math.round(Math.abs(newNetOffline));
            const newDir = newNetOffline > 0 ? "right" : "left";
            
            const numOptions = diffLevel <= 9 ? 5 : 6;
            let correctRange;
            if (newRoundedYards <= 6) correctRange = `0-6 yards ${newDir}`;
            else if (newRoundedYards <= 13) correctRange = `7-13 yards ${newDir}`;
            else if (newRoundedYards <= 20) correctRange = `14-20 yards ${newDir}`;
            else if (newRoundedYards <= 27) correctRange = `21-27 yards ${newDir}`;
            else correctRange = `28+ yards ${newDir}`;
            
            const allOptions = [
                "0-6 yards left", "7-13 yards left", "14-20 yards left", "21-27 yards left", "28+ yards left",
                "0-6 yards right", "7-13 yards right", "14-20 yards right", "21-27 yards right", "28+ yards right"
            ];
            const wrongOptions = allOptions.filter(o => o !== correctRange).sort(() => Math.random() - 0.5).slice(0, numOptions - 1);
            const options = [correctRange, ...wrongOptions].sort(() => Math.random() - 0.5);
            
            return {
                question: "If you CLOSED the face by 2Â° (keeping path the same), where would the ball finish?",
                options: options,
                correct: correctRange,
                explanation: `<div><strong>Original face:</strong> ${face.toFixed(1)}Â°</div><div><strong>New face:</strong> ${newFace.toFixed(1)}Â°</div><div><strong>New start direction:</strong> ${Math.abs(newFaceContribution).toFixed(1)} yards ${newFaceContribution > 0 ? 'right' : 'left'}</div><div><strong>New curve:</strong> ${Math.abs(newCurveContribution).toFixed(1)} yards ${newCurveContribution > 0 ? 'right' : 'left'}</div><div><strong>New final position:</strong> ${newRoundedYards} yards ${newDir}</div>`
            };
        }

        function generateLeastImpactQuestion(face, path, gearEffect, windEffect, diffLevel) {
            const faceContribution = Math.abs(face * 3);
            const pathContribution = Math.abs((face - path) * 5);
            const gearContribution = Math.abs(gearEffect * 5);
            const windContribution = Math.abs(windEffect);
            
            // Find LEAST impact
            const causes = [
                { name: "Face angle", value: faceContribution },
                { name: "Face-to-path", value: pathContribution },
                { name: "Gear effect", value: gearContribution },
                { name: "Wind", value: windContribution }
            ];
            causes.sort((a, b) => a.value - b.value); // Sort ascending - least first
            
            const numOptions = diffLevel <= 9 ? 5 : 6;
            const options = causes.slice(0, numOptions).map(c => c.name).sort(() => Math.random() - 0.5);
            
            return {
                question: "Which variable has the LEAST impact on the ball's final position?",
                options: options,
                correct: causes[0].name,
                explanation: `<div><strong>${causes[0].name}</strong> has the smallest impact with only ~${Math.round(causes[0].value)} yards of influence</div><div class="text-sm text-gray-600 mt-2">Others: ${causes.slice(1).map(c => c.name + ' ~' + Math.round(c.value) + 'yds').join(', ')}</div>`
            };
        }

        // Level 2: Will this shot curve? (Yes/No)
        function generateWillCurveQuestion(baseFaceToPath, diffLevel) {
            const willCurve = Math.abs(baseFaceToPath) > 1; // Threshold for "curve" vs "straight"
            const correct = willCurve ? "Yes" : "No";
            
            return {
                question: "Will this shot curve?",
                options: ["Yes", "No"],
                correct: correct,
                explanation: `<div><strong>Face-to-path:</strong> ${baseFaceToPath.toFixed(1)}Â°</div><div>${Math.abs(baseFaceToPath) > 1 ? 'Face and path differ significantly, creating sidespin that causes curve.' : 'Face and path are nearly aligned, ball flies relatively straight.'}</div>`
            };
        }

        // Level 2: Which direction will it curve?
        function generateCurveDirectionQuestion(baseFaceToPath, diffLevel) {
            let correct;
            if (Math.abs(baseFaceToPath) <= 1) {
                correct = "No curve (straight)";
            } else if (baseFaceToPath < 0) {
                correct = "Left";
            } else {
                correct = "Right";
            }
            
            const options = ["Left", "Right", "No curve (straight)"];
            
            return {
                question: "Which direction will the ball curve?",
                options: options,
                correct: correct,
                explanation: `<div><strong>Face-to-path:</strong> ${baseFaceToPath.toFixed(1)}Â°</div><div>${baseFaceToPath < -1 ? 'Face is LEFT of path â†’ draw spin â†’ curves LEFT' : baseFaceToPath > 1 ? 'Face is RIGHT of path â†’ fade spin â†’ curves RIGHT' : 'Face and path nearly aligned â†’ flies relatively STRAIGHT'}</div>`
            };
        }


        // Level 5-6: Face percentage control question
        function generateFacePercentageQuestion(club, physics, diffLevel) {
            const percentage = Math.round(physics.startFaceInfluence * 100);
            const correct = `${percentage}%`;
            
            // Generate nearby wrong answers
            const wrongPercentages = [percentage - 10, percentage - 5, percentage + 5, percentage + 10]
                .filter(p => p > 0 && p <= 100 && p !== percentage)
                .map(p => `${p}%`);
            
            const numOptions = diffLevel <= 9 ? 5 : 6;
            const selectedWrong = wrongPercentages.sort(() => Math.random() - 0.5).slice(0, numOptions - 1);
            const options = [correct, ...selectedWrong].sort(() => Math.random() - 0.5);
            
            return {
                question: "What percentage of the start direction is controlled by face angle?",
                options: options,
                correct: correct,
                explanation: `<div><strong>Club:</strong> ${club}</div><div>Face angle controls <strong>${percentage}%</strong> of initial direction for this club. Longer clubs (driver) have higher face influence (~85%), shorter clubs (wedges) have lower face influence (~70%).</div>`
            };
        }

        // Level 5-6: Curve comparison question
        function generateCurveComparisonQuestion(baseFaceToPath, gearEffect, clubType, diffLevel) {
            const faceToPathCurve = Math.abs(baseFaceToPath) * 5; // Approximate yards of curve
            const gearCurve = Math.abs(gearEffect) * 5;
            
            const correct = faceToPathCurve > gearCurve ? 
                `${Math.abs(baseFaceToPath).toFixed(1)}Â° face-to-path` : 
                `${Math.abs(gearEffect * 20).toFixed(1)}mm impact location`;
            
            const options = [
                `${Math.abs(baseFaceToPath).toFixed(1)}Â° face-to-path`,
                `${Math.abs(gearEffect * 20).toFixed(1)}mm impact location`,
                "They produce equal curve"
            ];
            
            return {
                question: "Which will produce MORE curve on this shot?",
                options: options,
                correct: correct,
                explanation: `<div><strong>Face-to-path curve:</strong> ~${faceToPathCurve.toFixed(1)} yards</div><div><strong>Gear effect curve:</strong> ~${gearCurve.toFixed(1)} yards</div><div>Face-to-path is the dominant factor in ball flight curvature.</div>`
            };
        }

        // Level 7: Lie angle effect direction
        function generateLieEffectDirectionQuestion(lieAngle, diffLevel) {
            let correct;
            if (lieAngle > 0.5) {
                correct = "Closes the face (ball goes left)";
            } else if (lieAngle < -0.5) {
                correct = "Opens the face (ball goes right)";
            } else {
                correct = "No significant effect";
            }
            
            const options = [
                "Opens the face (ball goes right)",
                "Closes the face (ball goes left)",
                "No significant effect"
            ];
            
            return {
                question: "How will the lie angle affect the face angle?",
                options: options,
                correct: correct,
                explanation: `<div><strong>Lie angle:</strong> ${Math.abs(lieAngle).toFixed(1)}Â° ${lieAngle > 0 ? 'upright' : 'flat'}</div><div>${lieAngle > 0.5 ? 'Upright lie CLOSES the face (aims left)' : lieAngle < -0.5 ? 'Flat lie OPENS the face (aims right)' : 'Standard lie has minimal effect'}</div>`
            };
        }

        // Level 7: Standard lie hypothetical
        function generateStandardLieHypotheticalQuestion(face, originalFace, lieAngleAdjustment, faceContribution, curveContribution, windEffect, diffLevel) {
            // Calculate what would happen with standard lie (no adjustment)
            const standardFace = originalFace; // No lie adjustment
            const standardFaceContribution = standardFace * 3;
            const standardNetOffline = standardFaceContribution + curveContribution + windEffect;
            const standardRoundedYards = Math.round(Math.abs(standardNetOffline));
            const standardDir = standardNetOffline > 0 ? "right" : "left";
            
            const numOptions = diffLevel <= 9 ? 5 : 6;
            let correctRange;
            if (standardRoundedYards <= 6) correctRange = `0-6 yards ${standardDir}`;
            else if (standardRoundedYards <= 13) correctRange = `7-13 yards ${standardDir}`;
            else if (standardRoundedYards <= 20) correctRange = `14-20 yards ${standardDir}`;
            else if (standardRoundedYards <= 27) correctRange = `21-27 yards ${standardDir}`;
            else correctRange = `28+ yards ${standardDir}`;
            
            const allOptions = [
                "0-6 yards left", "7-13 yards left", "14-20 yards left", "21-27 yards left", "28+ yards left",
                "0-6 yards right", "7-13 yards right", "14-20 yards right", "21-27 yards right", "28+ yards right"
            ];
            const wrongOptions = allOptions.filter(o => o !== correctRange).sort(() => Math.random() - 0.5).slice(0, numOptions - 1);
            const options = [correctRange, ...wrongOptions].sort(() => Math.random() - 0.5);
            
            return {
                question: "If this shot was hit with STANDARD lie angle instead, where would the ball finish?",
                options: options,
                correct: correctRange,
                explanation: `<div><strong>Current face (with lie):</strong> ${face.toFixed(1)}Â°</div><div><strong>Standard lie face:</strong> ${standardFace.toFixed(1)}Â°</div><div><strong>Difference:</strong> ${Math.abs(lieAngleAdjustment).toFixed(1)}Â° ${lieAngleAdjustment > 0 ? 'more open' : 'more closed'}</div><div><strong>Result with standard lie:</strong> ${standardRoundedYards} yards ${standardDir}</div>`
            };
        }

        // Level 8: Wind amplify/dampen question
        function generateWindAmplifyDampenQuestion(windDir, baseFaceToPath, diffLevel) {
            let correct;
            if (windDir === "Headwind") {
                correct = "Amplify the curve";
            } else if (windDir === "Tailwind") {
                correct = "Dampen the curve";
            } else {
                correct = "Not affect the curve significantly";
            }
            
            const options = ["Amplify the curve", "Dampen the curve", "Not affect the curve significantly"];
            
            let explanation;
            if (windDir === "Headwind") {
                explanation = `<div><strong>Wind:</strong> ${windDir}</div><div>Headwind increases spin rate and keeps the ball in the air longer, which AMPLIFIES sidespin and increases curve.</div>`;
            } else if (windDir === "Tailwind") {
                explanation = `<div><strong>Wind:</strong> ${windDir}</div><div>Tailwind reduces spin rate and shortens flight time, which DAMPENS sidespin and reduces curve.</div>`;
            } else {
                explanation = `<div><strong>Wind:</strong> ${windDir}</div><div>Crosswind primarily affects lateral movement but doesn't significantly change the curve from face-to-path.</div>`;
            }
            
            return {
                question: "Will the wind amplify or dampen the curve on this shot?",
                options: options,
                correct: correct,
                explanation: explanation
            };
        }

        // Level 8: Worst-case wind scenario
        function generateWorstWindScenarioQuestion(baseFaceToPath, diffLevel) {
            const curveDirection = baseFaceToPath < 0 ? "left" : "right";
            let correct;
            
            if (curveDirection === "left") {
                correct = "Headwind from the right";
            } else {
                correct = "Headwind from the left";
            }
            
            const options = [
                "Headwind from the left",
                "Headwind from the right",
                "Tailwind from the left",
                "Tailwind from the right"
            ];
            
            return {
                question: "What wind condition would make this shot go FURTHEST offline?",
                options: options,
                correct: correct,
                explanation: `<div><strong>Shot curves:</strong> ${curveDirection}</div><div>The worst case combines: (1) Headwind to AMPLIFY the curve, and (2) Crosswind pushing in the SAME direction as the curve.</div><div>This creates maximum offline distance.</div>`
            };
        }

        // Level 9-10: Opposing forces question
        function generateOpposingForcesQuestion(face, path, gearEffect, windEffect, baseFaceToPath, diffLevel) {
            const forces = [];
            
            // Check face-to-path direction
            const faceToPathDir = baseFaceToPath > 0 ? "right" : "left";
            
            // Check gear effect
            if (gearEffect !== 0) {
                const gearDir = gearEffect > 0 ? "right" : "left";
                if (gearDir !== faceToPathDir) {
                    forces.push(`Face-to-path (${faceToPathDir}) and Gear effect (${gearDir})`);
                }
            }
            
            // Check wind
            if (windEffect !== 0) {
                const windDir = windEffect > 0 ? "right" : "left";
                if (windDir !== faceToPathDir) {
                    forces.push(`Face-to-path (${faceToPathDir}) and Wind (${windDir})`);
                }
            }
            
            if (forces.length === 0) {
                forces.push("No opposing forces - all factors push the same direction");
            }
            
            const correct = forces[0];
            
            // Generate wrong options
            const allPossible = [
                `Face-to-path and Gear effect`,
                `Face-to-path and Wind`,
                `Gear effect and Wind`,
                `No opposing forces - all factors push the same direction`
            ];
            
            const wrongOptions = allPossible.filter(o => o !== correct).sort(() => Math.random() - 0.5).slice(0, 4);
            const options = [correct, ...wrongOptions].sort(() => Math.random() - 0.5);
            
            return {
                question: "Which TWO factors are working AGAINST each other?",
                options: options,
                correct: correct,
                explanation: `<div><strong>Face-to-path:</strong> ${baseFaceToPath.toFixed(1)}Â° (${faceToPathDir})</div><div><strong>Gear effect:</strong> ${gearEffect.toFixed(1)}Â° (${gearEffect > 0 ? 'right' : 'left'})</div><div><strong>Wind:</strong> ${windEffect.toFixed(1)} yards (${windEffect > 0 ? 'right' : 'left'})</div><div>Opposing forces make shots harder to predict and control.</div>`
            };
        }

        // Level 9-10: Best variable to change
        function generateBestVariableQuestion(face, path, gearEffect, windEffect, diffLevel) {
            // Calculate impact of changing each by 2Â°
            const faceDelta = Math.abs(2 * 3); // Face Ã— 3 = start yards
            const pathDelta = Math.abs(2 * 5); // Face-to-path change Ã— 5 = curve yards
            const totalFace = faceDelta;
            const totalPath = pathDelta;
            
            let correct;
            if (totalPath > totalFace * 1.5) {
                correct = "Club path (affects both start and curve)";
            } else {
                correct = "Club face (directly controls start direction)";
            }
            
            const options = [
                "Club face (directly controls start direction)",
                "Club path (affects both start and curve)",
                "Impact location (creates gear effect)",
                "They would all have equal impact"
            ];
            
            return {
                question: "If you could change ONE variable by 2Â°, which would improve the shot most?",
                options: options,
                correct: correct,
                explanation: `<div><strong>Changing face 2Â°:</strong> ~${faceDelta} yards start direction</div><div><strong>Changing path 2Â°:</strong> ~${pathDelta} yards curve change</div><div>Path changes affect BOTH the start (slightly) and curve (significantly), making it often the most impactful adjustment.</div>`
            };
        }

        // Level 9-10: Rank by impact
        function generateRankByImpactQuestion(face, path, gearEffect, windEffect, diffLevel) {
            const faceContribution = Math.abs(face * 3);
            const pathContribution = Math.abs((face - path) * 5);
            const gearContribution = Math.abs(gearEffect * 5);
            const windContribution = Math.abs(windEffect);
            
            const causes = [
                { name: "Face angle", value: faceContribution },
                { name: "Face-to-path", value: pathContribution },
                { name: "Gear effect", value: gearContribution },
                { name: "Wind", value: windContribution }
            ];
            causes.sort((a, b) => b.value - a.value); // Sort descending - highest first
            
            const correct = `${causes[0].name} > ${causes[1].name} > ${causes[2].name} > ${causes[3].name}`;
            
            // Generate a few wrong orderings
            const wrongOptions = [];
            const shuffled1 = [...causes].sort(() => Math.random() - 0.5);
            wrongOptions.push(`${shuffled1[0].name} > ${shuffled1[1].name} > ${shuffled1[2].name} > ${shuffled1[3].name}`);
            const shuffled2 = [...causes].sort(() => Math.random() - 0.5);
            wrongOptions.push(`${shuffled2[0].name} > ${shuffled2[1].name} > ${shuffled2[2].name} > ${shuffled2[3].name}`);
            
            const options = [correct, ...wrongOptions.filter(o => o !== correct).slice(0, 2)].sort(() => Math.random() - 0.5);
            
            return {
                question: "Rank these factors by their impact on the ball's final position (most to least):",
                options: options,
                correct: correct,
                explanation: `<div>${causes.map((c, i) => `<div><strong>#${i+1}: ${c.name}</strong> (~${Math.round(c.value)} yards impact)</div>`).join('')}</div>`
            };
        }

        function generateGearHelpHurtQuestion(gearEffect, baseFaceToPath, impactLocationText, diffLevel) {
            // Determine if gear effect is helping (opposing the curve) or hurting (adding to curve)
            const sameDirection = (gearEffect > 0 && baseFaceToPath > 0) || (gearEffect < 0 && baseFaceToPath < 0);
            const correct = sameDirection ? "Hurt (amplifies the curve)" : "Help (reduces the curve)";
            const wrong = sameDirection ? "Help (reduces the curve)" : "Hurt (amplifies the curve)";
            
            return {
                question: `Will the gear effect from ${impactLocationText} help or hurt this shot?`,
                options: [correct, wrong],
                correct: correct,
                explanation: `<div><strong>Base face-to-path:</strong> ${baseFaceToPath.toFixed(1)}Â° (${baseFaceToPath < 0 ? 'draw bias' : 'fade bias'})</div><div><strong>Gear effect:</strong> ${gearEffect.toFixed(1)}Â° (${gearEffect < 0 ? 'draw spin' : 'fade spin'})</div><div class="mt-2">${sameDirection ? 'The gear effect is in the SAME direction as face-to-path, making the curve worse!' : 'The gear effect is in the OPPOSITE direction from face-to-path, helping to straighten the shot.'}</div>`
            };
        }

        // Level 8: Will high/low face contact increase or decrease the curve?
        function generateVerticalImpactCurveQuestion(verticalImpact, verticalGearMultiplier, baseFaceToPath, diffLevel) {
            const isHigh = verticalImpact > 2; // High on face
            const isLow = verticalImpact < -2; // Low on face
            
            if (!isHigh && !isLow) {
                // Center strike - neutral question
                return {
                    question: "Will the center face contact significantly affect the curve?",
                    options: ["Yes", "No"],
                    correct: "No",
                    explanation: `<div><strong>Vertical impact:</strong> ${Math.abs(verticalImpact).toFixed(1)}mm (near center)</div><div>Center strikes produce normal spin rates without amplification or reduction.</div>`
                };
            }
            
            const impactType = isHigh ? "high" : "low";
            const effect = isHigh ? "Increase (amplifies spin)" : "Decrease (dampens spin)";
            const wrongEffect = isHigh ? "Decrease (dampens spin)" : "Increase (amplifies spin)";
            
            return {
                question: `Will the ${impactType} face contact increase or decrease the curve?`,
                options: [effect, wrongEffect],
                correct: effect,
                explanation: `<div><strong>Vertical impact:</strong> ${Math.abs(verticalImpact).toFixed(1)}mm ${impactType}</div><div><strong>Multiplier:</strong> ${verticalGearMultiplier.toFixed(2)}x</div><div class="mt-2">${isHigh ? 'High on the face creates more effective sidespin, amplifying the curve.' : 'Low on the face reduces sidespin effectiveness, dampening the curve.'}</div>`
            };
        }


        async function saveScore() {
            if (!state.user) return;
            
            const timestamp = new Date().toISOString();
            const scoreData = {
                name: state.user.name,
                level: state.difficulty,
                tokens: state.user.tokens,
                questionsAnswered: state.user.questionsAnswered,
                correctAnswers: state.user.correctAnswers,
                accuracy: state.user.questionsAnswered > 0 ? 
                    Math.round((state.user.correctAnswers / state.user.questionsAnswered) * 100) : 0,
                bestStreak: state.user.bestStreak,
                timestamp: timestamp,
                displayTime: new Date(timestamp).toLocaleString()
            };
            
            // Use consistent key for each player (no timestamp)
            const key = 'score_' + state.user.name.toLowerCase().replace(/\s+/g, '_');
            
            // Try window.storage first (global), fallback to localStorage
            try {
                // Check if player already has a score
                let existingScore = null;
                try {
                    const result = await window.storage.get(key, true);
                    if (result && result.value) {
                        existingScore = JSON.parse(result.value);
                    }
                } catch (e) {
                    // No existing score
                }
                
                // Only save if new score is better OR no existing score
                if (!existingScore || scoreData.tokens > existingScore.tokens) {
                    await window.storage.set(key, JSON.stringify(scoreData), true);
                }
            } catch (error) {
                // Fallback to localStorage
                try {
                    let existingScore = null;
                    const storedValue = localStorage.getItem(key);
                    if (storedValue) {
                        existingScore = JSON.parse(storedValue);
                    }
                    
                    // Only save if new score is better OR no existing score
                    if (!existingScore || scoreData.tokens > existingScore.tokens) {
                        localStorage.setItem(key, JSON.stringify(scoreData));
                    }
                } catch (e) {
                    console.log('Storage not available:', e.message);
                }
            }
        }

        async function loadLeaderboard() {
            let isGlobal = false;
            let scores = [];
            
            // Try window.storage first (global)
            try {
                const result = await window.storage.list('score_', true);
                if (result && result.keys) {
                    isGlobal = true;
                    for (const key of result.keys) {
                        try {
                            const scoreResult = await window.storage.get(key, true);
                            if (scoreResult && scoreResult.value) {
                                scores.push(JSON.parse(scoreResult.value));
                            }
                        } catch (e) {
                            console.error('Failed to load score:', e);
                        }
                    }
                }
            } catch (error) {
                // Fallback to localStorage
                try {
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('score_')) {
                            const value = localStorage.getItem(key);
                            if (value) {
                                scores.push(JSON.parse(value));
                            }
                        }
                    }
                } catch (e) {
                    console.error('Failed to load from localStorage:', e);
                }
            }
            
            scores.sort((a, b) => {
                if (b.tokens !== a.tokens) return b.tokens - a.tokens;
                return new Date(b.timestamp) - new Date(a.timestamp);
            });
            
            return { scores: scores.slice(0, 50), isGlobal };
        }

        function openLeaderboard() {
            const leaderboardWindow = window.open('', 'Leaderboard', 'width=1100,height=700');
            
            if (!leaderboardWindow) {
                alert('Please allow popups for this site to view the leaderboard!');
                return;
            }
            
            loadLeaderboard().then(data => {
                const { scores, isGlobal } = data;
                
                let html = `<!DOCTYPE html>
<html>
<head>
    <title>Leaderboard</title>
    <script src="https://cdn.tailwindcss.com"><` + `/script>
    <style>
        th { cursor: pointer; user-select: none; }
        th:hover { background-color: #f3f4f6; }
        .sort-arrow { display: inline-block; margin-left: 4px; }
    </style>
</head>
<body class="bg-gradient-to-br from-yellow-400 via-orange-500 to-red-600 p-8">
    <div class="max-w-6xl mx-auto bg-white rounded-2xl shadow-2xl p-8">
        <h1 class="text-4xl font-bold text-center mb-4 bg-gradient-to-r from-yellow-500 to-orange-500 bg-clip-text text-transparent">
            ðŸ† Leaderboard
        </h1>
        <div class="text-center mb-6">
            <span class="inline-block px-4 py-2 rounded-full text-sm font-semibold ${isGlobal ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'}">
                ${isGlobal ? 'ðŸŒ Global Leaderboard - Compete with players worldwide!' : 'ðŸ“Š Personal High Scores - Playing in local mode'}
            </span>
        </div>
        
        <div class="mb-4">
            <label class="font-semibold mr-2">Filter by Level:</label>
            <select id="levelFilter" onchange="filterScores()" class="px-4 py-2 border-2 border-gray-300 rounded-lg">
                <option value="all">All Levels</option>`;
                
                for (let i = 1; i <= 10; i++) {
                    html += `<option value="${i}">Level ${i}: ${difficultyLevels[i-1].name}</option>`;
                }
                
                html += `
            </select>
        </div>`;
                
                if (scores.length === 0) {
                    html += '<div class="text-center py-12"><p class="text-xl text-gray-600">No scores yet. Be the first!</p></div>';
                } else {
                    html += `
        <div class="overflow-x-auto">
            <table class="w-full" id="leaderboardTable">
                <thead>
                    <tr class="border-b-2 border-gray-300">
                        <th class="text-left py-3 px-4 font-bold text-gray-700">Rank</th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700">Player</th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700">Level</th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('tokens')">Tokens <span class="sort-arrow" id="arrow-tokens">â†“</span></th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('accuracy')">Accuracy <span class="sort-arrow" id="arrow-accuracy"></span></th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('correctAnswers')">Correct <span class="sort-arrow" id="arrow-correctAnswers"></span></th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('bestStreak')">Best Streak <span class="sort-arrow" id="arrow-bestStreak"></span></th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('timestamp')">Last Played <span class="sort-arrow" id="arrow-timestamp"></span></th>
                    </tr>
                </thead>
                <tbody id="leaderboardBody">
                </tbody>
            </table>
        </div>`;
                }
                
                html += `
    </div>
    <script>
        let allScores = ${JSON.stringify(scores)};
        let currentSort = { field: 'tokens', ascending: false };
        let currentFilter = 'all';
        
        const difficultyLevels = ${JSON.stringify(difficultyLevels)};
        
        function renderTable(scoresToShow) {
            const tbody = document.getElementById('leaderboardBody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            scoresToShow.forEach((score, idx) => {
                const medal = idx === 0 ? 'ðŸ¥‡' : idx === 1 ? 'ðŸ¥ˆ' : idx === 2 ? 'ðŸ¥‰' : (idx + 1);
                const rowClass = idx < 3 ? 'bg-yellow-50' : '';
                const row = document.createElement('tr');
                row.className = 'border-b border-gray-200 hover:bg-gray-50 ' + rowClass;
                row.innerHTML = \`
                    <td class="py-3 px-4 font-semibold">\${medal}</td>
                    <td class="py-3 px-4 font-medium">\${score.name}</td>
                    <td class="py-3 px-4"><span class="text-sm">\${difficultyLevels[score.level - 1].name}</span></td>
                    <td class="py-3 px-4"><span class="font-bold text-blue-600">\${score.tokens}</span></td>
                    <td class="py-3 px-4"><span class="text-sm">\${score.accuracy}%</span></td>
                    <td class="py-3 px-4"><span class="font-bold text-green-600">\${score.correctAnswers}</span></td>
                    <td class="py-3 px-4"><span class="font-bold text-purple-600">\${score.bestStreak || 0}</span></td>
                    <td class="py-3 px-4 text-sm text-gray-600">\${score.displayTime}</td>
                \`;
                tbody.appendChild(row);
            });
        }
        
        function sortBy(field) {
            if (currentSort.field === field) {
                currentSort.ascending = !currentSort.ascending;
            } else {
                currentSort.field = field;
                currentSort.ascending = field === 'timestamp';
            }
            
            // Clear all arrows
            document.querySelectorAll('.sort-arrow').forEach(el => el.textContent = '');
            
            // Set current arrow
            const arrow = document.getElementById('arrow-' + field);
            if (arrow) arrow.textContent = currentSort.ascending ? 'â†‘' : 'â†“';
            
            const filtered = filterScores(true);
            const sorted = [...filtered].sort((a, b) => {
                let aVal = a[field];
                let bVal = b[field];
                
                if (field === 'timestamp') {
                    aVal = new Date(aVal);
                    bVal = new Date(bVal);
                }
                
                if (currentSort.ascending) {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });
            
            renderTable(sorted);
        }
        
        function filterScores(returnOnly = false) {
            currentFilter = document.getElementById('levelFilter').value;
            
            let filtered = allScores;
            if (currentFilter !== 'all') {
                filtered = allScores.filter(s => s.level === parseInt(currentFilter));
            }
            
            if (returnOnly) return filtered;
            
            sortBy(currentSort.field);
        }
        
        // Initial render
        renderTable(allScores);
    <` + `/script>
</body>
</html>`;
                
                leaderboardWindow.document.write(html);
                leaderboardWindow.document.close();
            });
        }

        function selectLevel(level) {
            state.difficulty = level;
            
            // If we're in a game (not at level select), regenerate scenario with new level
            if (!state.showLevelSelect && state.currentScenarioData) {
                state.currentScenarioData = generateScenario(state.difficulty);
                state.currentCard = 1;
                state.selectedAnswer = null;
                state.showExplanation = false;
                state.isCorrect = false;
                
                // Auto-show tutorial if switching to a tutorial level not seen before
                const tutorialLevels = [1, 3, 5, 7, 8];
                if (tutorialLevels.includes(state.difficulty) && !state.tutorialsShown.includes(state.difficulty)) {
                    state.showTutorial = true;
                    state.tutorialLevel = state.difficulty;
                    state.tutorialsShown.push(state.difficulty);
                }
            }
            
            render();
        }

        function startGame() {
            state.showLevelSelect = false;
            state.currentScenarioData = generateScenario(state.difficulty);
            
            // Auto-show tutorial for key levels if not shown before
            const tutorialLevels = [1, 3, 5, 7, 8];
            if (tutorialLevels.includes(state.difficulty) && !state.tutorialsShown.includes(state.difficulty)) {
                state.showTutorial = true;
                state.tutorialLevel = state.difficulty;
                state.tutorialsShown.push(state.difficulty);
            } else {
                maybeShowConfidenceBoost();
            }
            
            render();
        }

        function maybeShowConfidenceBoost() {
            // Random chance (20%) to show confidence boost
            if (Math.random() < 0.2 && !state.showConfidenceBoost) {
                state.showConfidenceBoost = true;
                state.hasUsedBoost = false;
                state.boostCountdown = 20;
                // 50% chance to show before question, 50% after seeing the question
                state.boostTiming = Math.random() < 0.5 ? 'before' : 'after';
                
                // Start countdown timer
                if (state.boostTimer) clearInterval(state.boostTimer);
                state.boostTimer = setInterval(() => {
                    state.boostCountdown--;
                    if (state.boostCountdown <= 0) {
                        clearInterval(state.boostTimer);
                        state.showConfidenceBoost = false;
                        state.confidenceMultiplier = 1;
                    }
                    render();
                }, 1000);
            }
        }

        function getTutorialContent(level) {
            const tutorials = {
                1: {
                    title: "Level 1: Face, Path & Ball Flight Fundamentals",
                    content: `
                        <h3 class="text-xl font-bold mb-3" style="color: var(--augusta-green);">Welcome to Ball Flight Master!</h3>
                        <p class="mb-4">You're about to learn the foundational physics that governs every golf shot. Let's start with the two most important factors:</p>
                        
                        <div class="bg-green-50 border-l-4 border-green-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸ“ Club Face Angle</h4>
                            <p class="mb-2">The direction the clubface points at impact. This controls <strong>75-85%</strong> of the ball's starting direction.</p>
                            <ul class="list-disc ml-6 space-y-1">
                                <li><strong>Negative numbers</strong> = Face points LEFT of target</li>
                                <li><strong>Positive numbers</strong> = Face points RIGHT of target</li>
                                <li><strong>Zero</strong> = Face points at target (square)</li>
                            </ul>
                        </div>
                        
                        <div class="bg-blue-50 border-l-4 border-blue-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">â†—ï¸ Club Path</h4>
                            <p class="mb-2">The direction the clubhead is traveling through impact. This creates the curve.</p>
                            <ul class="list-disc ml-6 space-y-1">
                                <li><strong>Negative numbers</strong> = Swinging LEFT (in-to-out for right-hander)</li>
                                <li><strong>Positive numbers</strong> = Swinging RIGHT (out-to-in for right-hander)</li>
                                <li><strong>Zero</strong> = Swinging at target</li>
                            </ul>
                        </div>
                        
                        <div class="bg-yellow-50 border-l-4 border-yellow-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸŽ¯ The Golden Rule: Face-to-Path</h4>
                            <p class="mb-2">The ball curves based on the <strong>difference</strong> between face and path:</p>
                            <ul class="list-disc ml-6 space-y-1">
                                <li><strong>Face LEFT of path</strong> â†’ Ball curves LEFT (draw/hook)</li>
                                <li><strong>Face RIGHT of path</strong> â†’ Ball curves RIGHT (fade/slice)</li>
                                <li><strong>Face equals path</strong> â†’ Ball flies STRAIGHT</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-100 rounded-lg p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸ“Š Example Scenarios:</h4>
                            <div class="space-y-3">
                                <div class="bg-white p-3 rounded">
                                    <p class="font-semibold">Face: -2Â° | Path: +3Â°</p>
                                    <p class="text-sm">Face is 5Â° LEFT of path â†’ <span class="text-blue-600 font-bold">DRAW</span> (starts slightly left, curves more left)</p>
                                </div>
                                <div class="bg-white p-3 rounded">
                                    <p class="font-semibold">Face: +4Â° | Path: -1Â°</p>
                                    <p class="text-sm">Face is 5Â° RIGHT of path â†’ <span class="text-orange-600 font-bold">FADE</span> (starts right, curves more right)</p>
                                </div>
                                <div class="bg-white p-3 rounded">
                                    <p class="font-semibold">Face: +2Â° | Path: +2Â°</p>
                                    <p class="text-sm">Face equals path â†’ <span class="text-green-600 font-bold">PUSH</span> (starts right, flies straight)</p>
                                </div>
                            </div>
                        </div>
                        
                        <p class="text-sm italic text-gray-600">ðŸ’¡ Pro Tip: At Level 1, focus on calculating face-to-path. The hints will guide you through each step!</p>
                    `
                },
                3: {
                    title: "Level 3: Horizontal Gear Effect",
                    content: `
                        <h3 class="text-xl font-bold mb-3" style="color: var(--augusta-green);">New Variable: Impact Location (Toe/Heel)</h3>
                        <p class="mb-4">You've mastered face and path! Now we add a <strong>crucial real-world factor</strong>: where on the clubface you strike the ball.</p>
                        
                        <div class="bg-purple-50 border-l-4 border-purple-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">âš™ï¸ What is Gear Effect?</h4>
                            <p class="mb-2">When you hit the ball off-center horizontally, the clubface <strong>twists</strong> at impact. This twisting creates extra sidespin that affects the curve.</p>
                            <p class="text-sm italic">Think of it like hitting a ping-pong ball with sidespin - the face rotation imparts spin.</p>
                        </div>
                        
                        <div class="bg-orange-50 border-l-4 border-orange-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸŽ¯ Toe vs Heel Hits</h4>
                            <ul class="list-disc ml-6 space-y-2">
                                <li><strong>TOE HITS</strong> (positive mm):
                                    <ul class="list-circle ml-6 text-sm mt-1">
                                        <li>Face twists OPEN (right)</li>
                                        <li>Ball gets DRAW spin (curves left)</li>
                                        <li>This FIGHTS a natural fade</li>
                                        <li>Example: +15mm toe hit adds draw spin</li>
                                    </ul>
                                </li>
                                <li><strong>HEEL HITS</strong> (negative mm):
                                    <ul class="list-circle ml-6 text-sm mt-1">
                                        <li>Face twists CLOSED (left)</li>
                                        <li>Ball gets FADE spin (curves right)</li>
                                        <li>This FIGHTS a natural draw</li>
                                        <li>Example: -12mm heel hit adds fade spin</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-100 rounded-lg p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸ“Š How It Changes Shot Shape:</h4>
                            <div class="space-y-3">
                                <div class="bg-white p-3 rounded">
                                    <p class="font-semibold">Scenario: Face -3Â°, Path +2Â° (5Â° draw bias)</p>
                                    <p class="text-sm mt-1"><strong>Center strike:</strong> Clean draw</p>
                                    <p class="text-sm"><strong>Toe hit (+15mm):</strong> Draw becomes a HOOK (gear adds more draw)</p>
                                    <p class="text-sm"><strong>Heel hit (-15mm):</strong> Draw becomes STRAIGHT or even a slight fade (gear fights the draw)</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-yellow-50 border-l-4 border-yellow-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸ§® The Math</h4>
                            <p class="mb-2">Gear effect adds/subtracts from your face-to-path calculation:</p>
                            <ul class="list-disc ml-6 space-y-1 text-sm">
                                <li>Every 10mm toward toe â‰ˆ -0.5Â° to -0.8Â° (more draw)</li>
                                <li>Every 10mm toward heel â‰ˆ +0.5Â° to +0.8Â° (more fade)</li>
                                <li>Drivers have stronger gear effect than irons</li>
                            </ul>
                        </div>
                        
                        <p class="text-sm italic text-gray-600">ðŸ’¡ Pro Tip: Always consider if gear effect is HELPING or HURTING your face-to-path relationship!</p>
                        
                        <hr class="my-6 border-t-2 border-gray-300">
                        
                        <div class="bg-blue-50 rounded-lg p-4">
                            <h4 class="font-bold mb-3 text-lg" style="color: var(--augusta-green);">ðŸ“– What We've Already Learned:</h4>
                            <ul class="space-y-2 text-sm">
                                <li><strong>âœ… Level 1-2:</strong> Club face angle, Club path, Face-to-path calculation, Shot shapes, Curve direction</li>
                            </ul>
                        </div>
                    `
                },
                5: {
                    title: "Level 5: Vertical Gear Effect",
                    content: `
                        <h3 class="text-xl font-bold mb-3" style="color: var(--augusta-green);">New Variable: Vertical Impact (High/Low on Face)</h3>
                        <p class="mb-4">You understand horizontal gear effect. Now learn how <strong>vertical impact position</strong> affects sidespin effectiveness!</p>
                        
                        <div class="bg-indigo-50 border-l-4 border-indigo-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸ“ˆ High vs Low Face Contact</h4>
                            <p class="mb-2">Where you hit the ball vertically doesn't just affect distance - it <strong>amplifies or dampens sidespin</strong>.</p>
                            <ul class="list-disc ml-6 space-y-2">
                                <li><strong>HIGH on face</strong> (positive mm):
                                    <ul class="list-circle ml-6 text-sm mt-1">
                                        <li>Creates more effective sidespin</li>
                                        <li>Ball CURVES MORE than expected</li>
                                        <li>Draws become hooks, fades become slices</li>
                                        <li>Club-specific multipliers (driver vs iron)</li>
                                    </ul>
                                </li>
                                <li><strong>LOW on face</strong> (negative mm):
                                    <ul class="list-circle ml-6 text-sm mt-1">
                                        <li>Reduces sidespin effectiveness</li>
                                        <li>Ball CURVES LESS than expected</li>
                                        <li>Hooks become draws, slices become fades</li>
                                        <li>Can make shots straighter overall</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-100 rounded-lg p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸ“Š Real Example:</h4>
                            <div class="space-y-3">
                                <div class="bg-white p-3 rounded">
                                    <p class="font-semibold">Driver Shot: Face -4Â°, Path +2Â°, Toe +10mm</p>
                                    <p class="text-sm mt-1">Base calculation: 6Â° draw with toe helping = potential hook</p>
                                    <p class="text-sm mt-1"><strong>HIGH on face (+8mm):</strong> Sidespin amplified â†’ Severe HOOK</p>
                                    <p class="text-sm"><strong>CENTER vertically (0mm):</strong> Normal hook</p>
                                    <p class="text-sm"><strong>LOW on face (-8mm):</strong> Sidespin reduced â†’ Moderate DRAW</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-blue-50 border-l-4 border-blue-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸŽ® Club-Specific Multipliers</h4>
                            <p class="mb-2">Different clubs respond differently to vertical impact:</p>
                            <ul class="list-disc ml-6 space-y-1 text-sm">
                                <li><strong>Driver:</strong> 1.3x multiplier (high amplifies a LOT)</li>
                                <li><strong>Fairway Woods:</strong> 1.2x multiplier</li>
                                <li><strong>Hybrids:</strong> 1.15x multiplier</li>
                                <li><strong>Irons:</strong> 1.1x multiplier (more forgiving)</li>
                                <li><strong>Wedges:</strong> 1.05x multiplier (most forgiving)</li>
                            </ul>
                        </div>
                        
                        <div class="bg-yellow-50 border-l-4 border-yellow-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸ§  Strategic Thinking</h4>
                            <p class="mb-2">New questions you'll see:</p>
                            <ul class="list-disc ml-6 space-y-1 text-sm">
                                <li>"Will the high face contact increase or decrease the curve?"</li>
                                <li>"How does low impact affect this slice?"</li>
                                <li>You must now consider BOTH horizontal AND vertical gear effects simultaneously</li>
                            </ul>
                        </div>
                        
                        <p class="text-sm italic text-gray-600">ðŸ’¡ Pro Tip: High on face = more curve. Low on face = less curve. Simple rule with complex implications!</p>
                        
                        <hr class="my-6 border-t-2 border-gray-300">
                        
                        <div class="bg-blue-50 rounded-lg p-4">
                            <h4 class="font-bold mb-3 text-lg" style="color: var(--augusta-green);">ðŸ“– What We've Already Learned:</h4>
                            <ul class="space-y-2 text-sm">
                                <li><strong>âœ… Level 1-2:</strong> Face angle, Path, Face-to-path, Shot shapes, Curve direction</li>
                                <li><strong>âœ… Level 3-4:</strong> Horizontal gear effect (toe/heel), Start direction, Impact location affects curve</li>
                            </ul>
                        </div>
                    `
                },
                7: {
                    title: "Level 7: Lie Angle Effects",
                    content: `
                        <h3 class="text-xl font-bold mb-3" style="color: var(--augusta-green);">New Variable: Lie Angle</h3>
                        <p class="mb-4">Welcome to advanced golf physics! <strong>Lie angle</strong> is how upright or flat the club sits at address - and it <strong>changes your clubface angle</strong> at impact.</p>
                        
                        <div class="bg-red-50 border-l-4 border-red-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸ“ What is Lie Angle?</h4>
                            <p class="mb-2">The angle between the club shaft and the ground when addressing the ball.</p>
                            <ul class="list-disc ml-6 space-y-2">
                                <li><strong>UPRIGHT LIE</strong> (positive degrees):
                                    <ul class="list-circle ml-6 text-sm mt-1">
                                        <li>Shaft more vertical at address</li>
                                        <li>Toe UP in the air</li>
                                        <li>Face effectively CLOSES (points left)</li>
                                        <li>Club-specific multipliers (driver ~0.3, wedge ~0.7)</li>
                                    </ul>
                                </li>
                                <li><strong>FLAT LIE</strong> (negative degrees):
                                    <ul class="list-circle ml-6 text-sm mt-1">
                                        <li>Shaft more horizontal at address</li>
                                        <li>Heel UP in the air</li>
                                        <li>Face effectively OPENS (points right)</li>
                                        <li>Club-specific multipliers (driver ~0.3, wedge ~0.7)</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-100 rounded-lg p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸ“Š How Lie Angle Changes Everything:</h4>
                            <div class="space-y-3">
                                <div class="bg-white p-3 rounded">
                                    <p class="font-semibold">Example: Face shows -2Â°, Lie is +3Â° upright (Iron)</p>
                                    <p class="text-sm mt-1"><strong>Calculation:</strong> -2Â° face + (3Â° Ã— -0.5) = -3.5Â° effective face</p>
                                    <p class="text-sm text-blue-600 font-bold">The upright lie CLOSED the face by 1.5Â°!</p>
                                </div>
                                <div class="bg-white p-3 rounded">
                                    <p class="font-semibold">Example: Face shows +4Â°, Lie is -2Â° flat (Iron)</p>
                                    <p class="text-sm mt-1"><strong>Calculation:</strong> +4Â° face + (-2Â° Ã— -0.5) = +5Â° effective face</p>
                                    <p class="text-sm text-orange-600 font-bold">The flat lie OPENED the face by 1Â°!</p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-purple-50 border-l-4 border-purple-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">âš¡ Complex Interactions</h4>
                            <p class="mb-2">Now you're juggling FOUR variables simultaneously:</p>
                            <ol class="list-decimal ml-6 space-y-1 text-sm">
                                <li>Original face angle (modified by lie)</li>
                                <li>Path direction</li>
                                <li>Horizontal impact (toe/heel gear effect)</li>
                                <li>Vertical impact (high/low amplification)</li>
                            </ol>
                            <p class="mt-3 text-sm font-semibold">You must calculate the EFFECTIVE face after lie adjustment, then proceed with normal analysis!</p>
                        </div>
                        
                        <div class="bg-yellow-50 border-l-4 border-yellow-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸŽ¯ Why This Matters</h4>
                            <p class="mb-2 text-sm">Lie angle explains why:</p>
                            <ul class="list-disc ml-6 space-y-1 text-sm">
                                <li>Taller players tend to hook (upright clubs close face)</li>
                                <li>Shorter players tend to slice (flat clubs open face)</li>
                                <li>Getting fit for proper lie angle is crucial</li>
                                <li>Same swing can produce different results with different lies</li>
                            </ul>
                        </div>
                        
                        <p class="text-sm italic text-gray-600">ðŸ’¡ Pro Tip: Always calculate effective face FIRST (original face + lie adjustment), then analyze path relationship!</p>
                        
                        <hr class="my-6 border-t-2 border-gray-300">
                        
                        <div class="bg-blue-50 rounded-lg p-4">
                            <h4 class="font-bold mb-3 text-lg" style="color: var(--augusta-green);">ðŸ“– What We've Already Learned:</h4>
                            <ul class="space-y-2 text-sm">
                                <li><strong>âœ… Level 1-2:</strong> Face angle, Path, Face-to-path, Shot shapes, Curve direction</li>
                                <li><strong>âœ… Level 3-4:</strong> Horizontal gear effect (toe/heel), Start direction, Impact affects curve</li>
                                <li><strong>âœ… Level 5-6:</strong> Vertical gear effect (high/low), Spin amplification/dampening, Complex interactions</li>
                            </ul>
                        </div>
                    `
                },
                8: {
                    title: "Level 8: Wind Effects on Ball Flight",
                    content: `
                        <h3 class="text-xl font-bold mb-3" style="color: var(--augusta-green);">New Variable: Wind</h3>
                        <p class="mb-4">You've mastered club dynamics. Now face <strong>nature's wildcard</strong>: wind conditions that alter distance and curve!</p>
                        
                        <div class="bg-sky-50 border-l-4 border-sky-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸ’¨ Headwind (Against You)</h4>
                            <ul class="list-disc ml-6 space-y-2">
                                <li><strong>Distance:</strong> Loses ~2 yards per mph
                                    <ul class="list-circle ml-6 text-sm mt-1">
                                        <li>10 mph headwind = -20 yards carry</li>
                                        <li>20 mph headwind = -40 yards carry</li>
                                    </ul>
                                </li>
                                <li><strong>Spin Amplification:</strong> Makes ball curve MORE
                                    <ul class="list-circle ml-6 text-sm mt-1">
                                        <li>Draws become hooks in headwind</li>
                                        <li>Fades become slices in headwind</li>
                                        <li>Straight shots stay straighter (no spin to amplify)</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        
                        <div class="bg-green-50 border-l-4 border-green-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸƒ Tailwind (Helping You)</h4>
                            <ul class="list-disc ml-6 space-y-2">
                                <li><strong>Distance:</strong> Gains ~1 yard per mph
                                    <ul class="list-circle ml-6 text-sm mt-1">
                                        <li>10 mph tailwind = +10 yards carry</li>
                                        <li>20 mph tailwind = +20 yards carry</li>
                                        <li>Note: Less impact than headwind!</li>
                                    </ul>
                                </li>
                                <li><strong>Spin Reduction:</strong> Makes ball curve LESS
                                    <ul class="list-circle ml-6 text-sm mt-1">
                                        <li>Hooks become draws in tailwind</li>
                                        <li>Slices become fades in tailwind</li>
                                        <li>Helps straighten out bad shots</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        
                        <div class="bg-orange-50 border-l-4 border-orange-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">â†”ï¸ Crosswind (Left or Right)</h4>
                            <p class="mb-2">Pushes the ball laterally based on carry distance:</p>
                            <ul class="list-disc ml-6 space-y-1 text-sm">
                                <li><strong>Tier 1 (Weak):</strong> 0.5 yards per 10 yards carry per 10mph wind</li>
                                <li><strong>Tier 2 (Medium):</strong> 0.75 yards per 10 yards carry per 10mph wind</li>
                                <li><strong>Tier 3 (Strong):</strong> 1.0 yards per 10 yards carry per 10mph wind</li>
                            </ul>
                            <div class="bg-white p-3 rounded mt-3">
                                <p class="font-semibold text-sm">Example: 200yd carry, 15mph crosswind (Tier 2)</p>
                                <p class="text-sm">Lateral push = (200 / 10) Ã— 0.75 Ã— 1.5 = 22.5 yards sideways!</p>
                            </div>
                        </div>
                        
                        <div class="bg-gray-100 rounded-lg p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸ“Š Wind Distribution (Bell Curve)</h4>
                            <p class="text-sm mb-2">Wind speed follows a realistic bell curve centered at 7mph:</p>
                            <ul class="list-disc ml-6 space-y-1 text-sm">
                                <li>Most common: 5-9 mph (moderate breeze)</li>
                                <li>Occasional: 0-4 mph (calm) or 10-14 mph (breezy)</li>
                                <li>Rare: 15+ mph (windy conditions)</li>
                                <li>Direction: Random (head/tail/cross left/cross right)</li>
                            </ul>
                        </div>
                        
                        <div class="bg-yellow-50 border-l-4 border-yellow-600 p-4 mb-4">
                            <h4 class="font-bold mb-2">ðŸ§  Strategic Questions</h4>
                            <p class="mb-2 text-sm">New challenges at Level 8:</p>
                            <ul class="list-disc ml-6 space-y-1 text-sm">
                                <li>"Will this headwind help or hurt the shot shape?"</li>
                                <li>"How does tailwind change the curve severity?"</li>
                                <li>Hypothetical scenarios with different wind conditions</li>
                                <li>15% trick scenarios (watch out!)</li>
                            </ul>
                        </div>
                        
                        <p class="text-sm italic text-gray-600">ðŸ’¡ Pro Tip: Headwind = more curve. Tailwind = less curve. Crosswind = lateral push. Master these and you're ready for any conditions!</p>
                        
                        <hr class="my-6 border-t-2 border-gray-300">
                        
                        <div class="bg-blue-50 rounded-lg p-4">
                            <h4 class="font-bold mb-3 text-lg" style="color: var(--augusta-green);">ðŸ“– What We've Already Learned:</h4>
                            <ul class="space-y-2 text-sm">
                                <li><strong>âœ… Level 1-2:</strong> Face angle, Path, Face-to-path, Shot shapes, Curve direction</li>
                                <li><strong>âœ… Level 3-4:</strong> Horizontal gear effect (toe/heel), Start direction, Impact affects curve</li>
                                <li><strong>âœ… Level 5-6:</strong> Vertical gear effect (high/low), Spin amplification/dampening, Complex interactions</li>
                                <li><strong>âœ… Level 7:</strong> Lie angle effects, Effective face calculation, Club-specific multipliers</li>
                            </ul>
                        </div>
                    `
                }
            };
            
            return tutorials[level] || {
                title: `Level ${level} Tutorial`,
                content: `<p>Tutorial content for this level is coming soon!</p>`
            };
        }

        function showTutorial(level) {
            state.showTutorial = true;
            state.tutorialLevel = level;
            
            // Mark this level's tutorial as shown
            if (!state.tutorialsShown.includes(level)) {
                state.tutorialsShown.push(level);
            }
            
            render();
        }

        function closeTutorial() {
            state.showTutorial = false;
            render();
        }

        // Track performance for adaptive level-up
        function trackLevelPerformance(level, correct, total) {
            if (!state.levelPerformance[level]) {
                state.levelPerformance[level] = {
                    scenarios: 0,
                    correct: 0,
                    total: 0,
                    recent: [] // Last 5 scenarios: cards correct out of total
                };
            }
            
            const perf = state.levelPerformance[level];
            perf.scenarios++;
            perf.correct += correct;
            perf.total += total;
            
            // Track recent performance (last 5 scenarios)
            perf.recent.push({ correct, total });
            if (perf.recent.length > 5) {
                perf.recent.shift(); // Keep only last 5
            }
        }

        // Check if player should be promoted to next level
        function checkLevelPromotion(currentLevel) {
            if (currentLevel >= 10) return false; // Already at max level
            
            const perf = state.levelPerformance[currentLevel];
            if (!perf || perf.scenarios < 15) return false; // Need at least 15 scenarios
            
            // Calculate overall accuracy
            const overallAccuracy = perf.correct / perf.total;
            if (overallAccuracy < 0.80) return false; // Need 80%+ overall
            
            // Calculate recent accuracy (last 5 scenarios)
            if (perf.recent.length < 5) return false; // Need 5 recent scenarios
            
            let recentCorrect = 0;
            let recentTotal = 0;
            let hasTerribleRun = false;
            
            for (const scenario of perf.recent) {
                recentCorrect += scenario.correct;
                recentTotal += scenario.total;
                
                // Check for terrible performance (below 50%)
                if (scenario.correct / scenario.total < 0.5) {
                    hasTerribleRun = true;
                }
            }
            
            const recentAccuracy = recentCorrect / recentTotal;
            if (recentAccuracy < 0.75) return false; // Need 75%+ recent average
            if (hasTerribleRun) return false; // No terrible runs in last 5
            
            return true; // Ready to promote!
        }

        function showLevelUpPromotion(targetLevel) {
            state.showLevelUpPromotion = true;
            state.promotionTargetLevel = targetLevel;
            render();
        }

        function acceptPromotion() {
            state.difficulty = state.promotionTargetLevel;
            state.showLevelUpPromotion = false;
            state.scenarioNumber = 1;
            state.currentCard = 1;
            state.currentScenarioData = generateScenario(state.difficulty);
            
            // Auto-show tutorial if applicable
            const tutorialLevels = [1, 3, 5, 7, 8];
            if (tutorialLevels.includes(state.difficulty) && !state.tutorialsShown.includes(state.difficulty)) {
                state.showTutorial = true;
                state.tutorialLevel = state.difficulty;
                state.tutorialsShown.push(state.difficulty);
            }
            
            render();
        }

        function declinePromotion() {
            state.showLevelUpPromotion = false;
            render();
        }


        function selectConfidence(multiplier) {
            state.confidenceMultiplier = multiplier;
            state.showConfidenceBoost = false;
            state.hasUsedBoost = true;
            state.boostCardResults = [];
            state.boostLost = false;
            if (state.boostTimer) {
                clearInterval(state.boostTimer);
                state.boostTimer = null;
            }
            render();
        }

        function render() {
            const app = document.getElementById('app');
            
            if (state.showAuth) {
                app.innerHTML = `
                    <div class="min-h-screen golf-bg p-6 flex items-center justify-center">
                        <div class="bg-white rounded-lg shadow-2xl max-w-md w-full relative">
                            <div class="absolute top-3 right-3 text-xs text-gray-400 bg-white/90 px-2 py-1 rounded">
                                ${APP_VERSION}
                            </div>
                            <div class="p-6 rounded-t-lg text-center" style="background: linear-gradient(135deg, var(--augusta-green), var(--augusta-dark));">
                                <div class="text-6xl mb-3">ðŸŒï¸â€â™‚ï¸â›³</div>
                                <h1 class="text-4xl font-bold text-white mb-2">Ball Flight Master</h1>
                                <p class="text-sm" style="color: var(--masters-gold); font-weight: 600; letter-spacing: 1px;">EARN THE GREEN JACKET OF GOLF PHYSICS</p>
                            </div>
                            <div class="p-8">
                                <div class="text-center mb-6">
                                    <p class="text-gray-700 text-lg mb-2 font-semibold">Learn the Science Behind Every Shot</p>
                                    <p class="text-gray-500 text-sm">Learn â€¢ Practice â€¢ Compete</p>
                                </div>
                                <input type="text" id="username" value="${state.username}" 
                                    placeholder="Enter your username" 
                                    class="w-full p-3 border-2 border-gray-300 rounded-lg mb-4 text-lg focus:border-green-600 focus:outline-none">
                                <button onclick="handleLogin()" 
                                    class="w-full py-3 text-white rounded-lg font-semibold text-lg transition-all hover:opacity-90"
                                    style="background: var(--augusta-green);">
                                    â›³ Start Playing
                                </button>
                                <button onclick="openLeaderboard()" 
                                    class="w-full mt-3 py-3 text-white rounded-lg font-semibold transition-all hover:opacity-90"
                                    style="background: var(--masters-gold); color: #000;">
                                    ðŸ† View Leaderboard
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                document.getElementById('username').addEventListener('input', e => {
                    state.username = e.target.value;
                });
                return;
            }

            if (state.showLevelSelect) {
                app.innerHTML = `
                    <div class="min-h-screen golf-bg p-4">
                        <div class="max-w-6xl mx-auto">
                            <div class="bg-white rounded-2xl shadow-2xl p-8 mb-4 relative">
                                <div class="absolute top-3 right-3 text-xs text-gray-400 bg-white/90 px-2 py-1 rounded">
                                    ${APP_VERSION}
                                </div>
                                <div class="text-center mb-2">
                                    <div class="text-5xl mb-3">â›³</div>
                                    <h1 class="text-4xl font-bold mb-2" style="color: var(--augusta-green);">
                                        Welcome, ${state.username}!
                                    </h1>
                                    <p class="text-gray-600 mb-6">Choose Your Path to the Green Jacket</p>
                                </div>
                                
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    ${difficultyLevels.map(level => `
                                        <div class="border-2 rounded-xl p-6 cursor-pointer hover:shadow-lg transition-all ${state.difficulty === level.level ? 'border-green-600 bg-green-50' : 'border-gray-300'}"
                                            style="${state.difficulty === level.level ? 'border-color: var(--augusta-green);' : ''}"
                                            onclick="selectLevel(${level.level})">
                                            <div class="flex items-start justify-between mb-3">
                                                <div>
                                                    <h3 class="text-xl font-bold text-gray-900">ðŸŒï¸ Level ${level.level}: ${level.name}</h3>
                                                    <p class="text-sm text-gray-600 mt-1">${level.description}</p>
                                                </div>
                                                <span class="px-3 py-1 rounded-full text-sm font-semibold" style="background: var(--masters-gold); color: #000;">
                                                    +${level.baseReward}
                                                </span>
                                            </div>
                                            
                                            <div class="bg-gray-50 rounded-lg p-4 mb-3">
                                                <p class="text-sm text-gray-700">${level.details}</p>
                                            </div>
                                            
                                            <div class="flex gap-4 text-sm">
                                                <div class="flex items-center gap-2">
                                                    <span class="text-gray-600">Cards:</span>
                                                    <span class="font-semibold">${level.cards}</span>
                                                </div>
                                                <div class="flex items-center gap-2">
                                                    <span class="text-gray-600">Reward:</span>
                                                    <span class="font-semibold" style="color: var(--augusta-green);">+${level.baseReward}</span>
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                                
                                <div class="flex gap-3 mt-6">
                                    ${[1, 3, 5, 7, 8].includes(state.difficulty) ? `
                                        <button onclick="showTutorial(${state.difficulty})" 
                                            class="flex-1 py-4 rounded-lg font-semibold text-lg hover:shadow-lg transition-all"
                                            style="background: rgba(212, 175, 55, 0.15); color: var(--masters-gold); border: 2px solid var(--masters-gold);">
                                            ðŸ“š View Level ${state.difficulty} Tutorial
                                        </button>
                                    ` : ''}
                                    <button onclick="startGame()" 
                                        class="${[1, 3, 5, 7, 8].includes(state.difficulty) ? 'flex-1' : 'w-full'} py-4 text-white rounded-lg font-semibold text-lg hover:shadow-lg transition-all hover:opacity-90"
                                        style="background: var(--augusta-green);">
                                        â›³ Start Level ${state.difficulty}: ${difficultyLevels[state.difficulty - 1].name}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                return;
            }

            if (!state.currentScenarioData) return;

            const totalCards = difficultyLevels[state.difficulty - 1].cards;
            const card = state.currentScenarioData.cards[state.currentCard - 1];
            const accuracy = state.user.questionsAnswered > 0 ? Math.round((state.user.correctAnswers / state.user.questionsAnswered) * 100) : 0;

            let dataHTML = '';
            const tooltips = getDataTooltips(state.difficulty);
            for (let [key, item] of Object.entries(state.currentScenarioData.data)) {
                const tooltipText = tooltips[item.label] || "Hover for more information";
                dataHTML += `
                    <div class="data-card">
                        <div class="bg-gradient-to-br from-blue-50 to-indigo-50 border-2 border-blue-200 rounded-xl p-5 shadow-md hover:shadow-lg transition-all">
                            <div class="flex items-center gap-3 mb-2">
                                <span class="text-3xl">${item.icon}</span>
                                <span class="font-bold text-gray-700 text-sm">${item.label}</span>
                            </div>
                            <div class="text-xl font-bold text-gray-900 mt-2">${item.value}</div>
                        </div>
                        <div class="tooltip">${tooltipText}</div>
                    </div>
                `;
            }

            let optionsHTML = '';
            card.options.forEach((opt, idx) => {
                // Get description for shot shapes (if it exists in shotShapeDescriptions)
                const description = shotShapeDescriptions[opt] || '';
                let btnClass = "w-full text-left p-5 rounded-xl border-2 transition-all font-semibold shadow-md hover:shadow-lg";
                if (!state.showExplanation) {
                    btnClass += state.selectedAnswer === opt ? " border-purple-600 bg-purple-600 text-white" : " border-gray-300 bg-white hover:border-purple-400 hover:bg-purple-50";
                } else {
                    // Check correctness - now options are plain names
                    const isCorrect = opt === card.correct;
                    if (isCorrect) btnClass += " border-green-600 bg-green-500 text-white";
                    else if (opt === state.selectedAnswer) btnClass += " border-red-600 bg-red-500 text-white";
                    else btnClass += " border-gray-300 bg-gray-200 text-gray-500";
                }
                
                optionsHTML += `
                    <button onclick="handleAnswer('${opt.replace(/'/g, "\\'")}')" 
                        ${state.showExplanation ? 'disabled' : ''}
                        class="${btnClass}">
                        <div class="text-lg font-bold mb-1">${opt}</div>
                        ${description ? `<div class="shot-description">${description}</div>` : ''}
                    </button>
                `;
            });

            app.innerHTML = `
                <div class="min-h-screen golf-bg p-6">
                    <div class="max-w-5xl mx-auto relative">
                        <div class="absolute -top-2 right-2 text-xs text-white/80 bg-black/40 px-3 py-1.5 rounded-lg backdrop-blur-sm shadow-lg" style="z-index: 100;">
                            ${APP_VERSION}
                        </div>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                            <div class="text-white shadow-lg rounded-lg p-4 text-center" style="background: linear-gradient(135deg, var(--masters-gold), #B8860B);">
                                <p class="text-sm opacity-90">Tokens</p>
                                <p class="text-2xl font-bold text-black">${state.user.tokens}</p>
                            </div>
                            <div class="bg-gradient-to-br from-purple-500 to-pink-500 text-white shadow-lg rounded-lg p-4 text-center">
                                <p class="text-sm opacity-90">Accuracy</p>
                                <p class="text-2xl font-bold">${accuracy}%</p>
                            </div>
                            <div class="bg-gradient-to-br from-green-500 to-teal-500 text-white shadow-lg rounded-lg p-4 text-center">
                                <p class="text-sm opacity-90">Correct</p>
                                <p class="text-2xl font-bold">${state.user.correctAnswers}</p>
                            </div>
                            <div class="bg-gradient-to-br from-blue-500 to-indigo-500 text-white shadow-lg rounded-lg p-4 text-center">
                                <p class="text-sm opacity-90">Streak</p>
                                <p class="text-2xl font-bold">${state.user.currentStreak} ðŸ”¥</p>
                            </div>
                        </div>

                        ${state.hasUsedBoost ? `
                            <div class="mb-6 p-4 rounded-xl shadow-lg ${state.boostLost ? 'bg-gray-300 opacity-75' : 'bg-gradient-to-r from-yellow-400 to-orange-500'}">
                                <div class="text-center">
                                    <div class="text-2xl font-bold ${state.boostLost ? 'text-gray-700' : 'text-white'} mb-2">
                                        ${state.boostLost ? 'âŒ' : 'ðŸŽ¯'} ${state.boostLost ? '<span class="line-through">' + state.confidenceMultiplier + 'x</span>' : state.confidenceMultiplier + 'x'} BOOST ${state.boostLost ? 'LOST' : 'ACTIVE'}
                                    </div>
                                    <div class="flex justify-center items-center gap-2 mb-2">
                                        <span class="${state.boostLost ? 'text-gray-700' : 'text-white'} font-semibold">Progress:</span>
                                        ${Array.from({length: difficultyLevels[state.difficulty - 1].cards}, (_, i) => {
                                            if (i < state.boostCardResults.length) {
                                                return state.boostCardResults[i] ? '<span class="text-2xl">âœ“</span>' : '<span class="text-2xl text-red-600">âœ—</span>';
                                            } else {
                                                return '<span class="text-2xl text-white">â—‹</span>';
                                            }
                                        }).join('')}
                                        <span class="${state.boostLost ? 'text-gray-700' : 'text-white'} text-sm">(${state.boostCardResults.length}/${difficultyLevels[state.difficulty - 1].cards} cards)</span>
                                    </div>
                                    ${state.boostLost ? `
                                        <div class="text-sm text-gray-700 font-semibold">Failed Card ${state.boostCardResults.findIndex(r => !r) + 1}</div>
                                    ` : state.boostCardResults.length > 0 && state.boostCardResults.length < difficultyLevels[state.difficulty - 1].cards ? `
                                        <div class="text-sm text-white font-semibold">Still eligible! ${difficultyLevels[state.difficulty - 1].cards - state.boostCardResults.length} card(s) remaining</div>
                                    ` : ''}
                                </div>
                            </div>
                        ` : ''}

                        <div class="bg-white rounded-lg shadow-lg p-4 mb-6">
                            <div class="flex justify-between items-center">
                                <div>
                                    <h3 class="font-bold text-lg">Level ${state.difficulty} - ${difficultyLevels[state.difficulty - 1].name}</h3>
                                    <p class="text-sm text-gray-600">${difficultyLevels[state.difficulty - 1].description}</p>
                                </div>
                                <button onclick="showTutorial(${state.difficulty})" class="px-4 py-2 text-white rounded-lg mr-2" style="background: var(--masters-gold); color: var(--augusta-dark); font-weight: 600;">
                                    ðŸ“š Tutorial
                                </button>
                                <button onclick="toggleDifficulty()" class="px-4 py-2 bg-blue-600 text-white rounded-lg mr-2">
                                    Change Level
                                </button>
                                <button onclick="openLeaderboard()" class="px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600">
                                    ðŸ†
                                </button>
                            </div>
                            ${state.showDifficultySelector ? `
                                <div class="mt-4">
                                    <input type="range" min="1" max="10" value="${state.difficulty}" 
                                        oninput="changeDifficulty(this.value)" class="w-full">
                                    <div class="flex justify-between text-xs text-gray-600 mt-2">
                                        ${difficultyLevels.map(d => `<span class="${d.level === state.difficulty ? 'font-bold text-blue-600' : ''}">${d.level}</span>`).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>

                        <div class="bg-white rounded-lg shadow-2xl">
                            <div class="text-white p-6 rounded-t-lg" style="background: linear-gradient(135deg, var(--augusta-green), var(--augusta-dark));">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <h2 class="text-2xl font-bold">Level ${state.difficulty} â€¢ Scenario #${state.scenarioNumber} â€¢ Card ${state.currentCard} of ${totalCards}</h2>
                                        <p class="text-green-100">Base Reward: ${difficultyLevels[state.difficulty - 1].baseReward} tokens</p>
                                    </div>
                                    ${state.currentScenarioData.isTrickScenario ? `
                                        <div class="bg-yellow-500 text-black px-4 py-2 rounded-lg font-bold text-sm shadow-lg animate-pulse">
                                            âš¡ TRICK SCENARIO
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                            <div class="p-6">
                                <div class="mb-6">
                                    <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                                        ${dataHTML}
                                    </div>
                                </div>

                                ${state.showConfidenceBoost && !state.selectedAnswer && state.boostTiming === 'before' ? `
                                    <div class="mb-6 p-6 bg-gradient-to-r from-yellow-400 to-orange-500 border-4 border-yellow-600 rounded-xl shadow-2xl">
                                        <h3 class="text-3xl font-bold text-white mb-3 text-center">ðŸŽ¯ CONFIDENCE BOOSTER! ðŸŽ¯</h3>
                                        <p class="text-white text-lg mb-4 text-center">We're showing you this BEFORE revealing the question! This is a true test of confidence.</p>
                                        <p class="text-white font-semibold mb-4 text-center">Choose your multiplier now, then answer the question:</p>
                                        
                                        <!-- Bomb Countdown -->
                                        <div class="mb-4 bg-white/30 rounded-lg p-3">
                                            <div class="flex items-center justify-between mb-2">
                                                <span class="text-white font-bold">Time remaining: ${state.boostCountdown}s</span>
                                                <span class="text-white font-bold">${state.boostCountdown <= 5 ? 'âš ï¸ HURRY!' : ''}</span>
                                            </div>
                                            <div class="relative h-8 bg-white/20 rounded-full overflow-hidden">
                                                <div class="absolute top-0 left-0 h-full bg-red-500/50 transition-all duration-1000" style="width: ${(state.boostCountdown / 20) * 100}%"></div>
                                                <div class="absolute top-1/2 -translate-y-1/2 transition-all duration-1000" style="left: ${((20 - state.boostCountdown) / 20) * 100}%">
                                                    <span class="text-3xl">${state.boostCountdown <= 3 ? 'ðŸ’¥' : 'ðŸ’£'}</span>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div class="grid grid-cols-3 gap-4">
                                            <button onclick="selectConfidence(1)" class="bg-white text-gray-900 p-4 rounded-lg font-bold text-xl hover:bg-gray-100 transition-all">
                                                1x<br><span class="text-sm">Play it safe</span>
                                            </button>
                                            <button onclick="selectConfidence(2)" class="bg-white text-orange-600 p-4 rounded-lg font-bold text-xl hover:bg-orange-50 transition-all">
                                                2x<br><span class="text-sm">Feeling good!</span>
                                            </button>
                                            <button onclick="selectConfidence(3)" class="bg-white text-red-600 p-4 rounded-lg font-bold text-xl hover:bg-red-50 transition-all">
                                                3x<br><span class="text-sm">All in!</span>
                                            </button>
                                        </div>
                                    </div>
                                ` : ''}

                                ${state.showConfidenceBoost && !state.selectedAnswer && state.boostTiming === 'after' ? `
                                    <div class="mb-6 p-6 bg-gradient-to-r from-blue-400 to-purple-500 border-4 border-blue-600 rounded-xl shadow-2xl">
                                        <h3 class="text-3xl font-bold text-white mb-3 text-center">ðŸŽ¯ CONFIDENCE BOOSTER! ðŸŽ¯</h3>
                                        <p class="text-white text-lg mb-4 text-center">You've seen the question and data. How confident are you?</p>
                                        <p class="text-white font-semibold mb-4 text-center">Choose your multiplier:</p>
                                        
                                        <!-- Bomb Countdown -->
                                        <div class="mb-4 bg-white/30 rounded-lg p-3">
                                            <div class="flex items-center justify-between mb-2">
                                                <span class="text-white font-bold">Time remaining: ${state.boostCountdown}s</span>
                                                <span class="text-white font-bold">${state.boostCountdown <= 5 ? 'âš ï¸ HURRY!' : ''}</span>
                                            </div>
                                            <div class="relative h-8 bg-white/20 rounded-full overflow-hidden">
                                                <div class="absolute top-0 left-0 h-full bg-red-500/50 transition-all duration-1000" style="width: ${(state.boostCountdown / 20) * 100}%"></div>
                                                <div class="absolute top-1/2 -translate-y-1/2 transition-all duration-1000" style="left: ${((20 - state.boostCountdown) / 20) * 100}%">
                                                    <span class="text-3xl">${state.boostCountdown <= 3 ? 'ðŸ’¥' : 'ðŸ’£'}</span>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div class="grid grid-cols-3 gap-4">
                                            <button onclick="selectConfidence(1)" class="bg-white text-gray-900 p-4 rounded-lg font-bold text-xl hover:bg-gray-100 transition-all">
                                                1x<br><span class="text-sm">Not sure</span>
                                            </button>
                                            <button onclick="selectConfidence(2)" class="bg-white text-orange-600 p-4 rounded-lg font-bold text-xl hover:bg-orange-50 transition-all">
                                                2x<br><span class="text-sm">Pretty sure!</span>
                                            </button>
                                            <button onclick="selectConfidence(3)" class="bg-white text-red-600 p-4 rounded-lg font-bold text-xl hover:bg-red-50 transition-all">
                                                3x<br><span class="text-sm">Definitely!</span>
                                            </button>
                                        </div>
                                    </div>
                                ` : ''}

                                <h3 class="font-bold text-2xl mb-4 text-purple-900">${card.question}</h3>

                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                    ${optionsHTML}
                                </div>

                                ${state.showExplanation ? `
                                    <div class="p-4 rounded-lg mb-4 ${state.isCorrect ? 'bg-green-50 border-2 border-green-500' : 'bg-red-50 border-2 border-red-500'}">
                                        ${(() => {
                                            const totalCards = difficultyLevels[state.difficulty - 1].cards;
                                            const baseReward = difficultyLevels[state.difficulty - 1].baseReward;
                                            const isLastCard = state.currentCard >= totalCards;
                                            const allCorrect = state.boostCardResults.every(r => r === true) && state.boostCardResults.length === totalCards;
                                            
                                            if (state.isCorrect) {
                                                if (state.hasUsedBoost && isLastCard) {
                                                    if (allCorrect && !state.boostLost) {
                                                        const multipliedReward = baseReward * state.confidenceMultiplier;
                                                        return `<p class="font-bold text-lg">âœ“ Correct! You got ALL ${totalCards} cards correct!</p><p class="text-lg mt-2">ðŸŽ¯ ${state.confidenceMultiplier}x multiplier applied: <span class="text-green-700">+${multipliedReward} tokens</span> (${baseReward} base Ã— ${state.confidenceMultiplier})</p>`;
                                                    } else {
                                                        return `<p class="font-bold text-lg">âœ“ Correct! +${baseReward} tokens</p><p class="text-sm mt-2 text-red-600">Lost ${state.confidenceMultiplier}x multiplier from earlier incorrect answer</p>`;
                                                    }
                                                } else if (state.hasUsedBoost && !isLastCard) {
                                                    const remaining = totalCards - state.currentCard;
                                                    return `<p class="font-bold text-lg">âœ“ Correct! Still eligible for ${state.confidenceMultiplier}x boost!</p><p class="text-sm mt-2">${remaining} card(s) remaining - get them all correct to earn the bonus!</p>`;
                                                } else {
                                                    return `<p class="font-bold text-lg">âœ“ Correct! +${baseReward} tokens</p>`;
                                                }
                                            } else {
                                                // Wrong answer - show penalty
                                                const penaltyPercent = 0.25 + (state.difficulty - 1) * (0.75 / 9);
                                                const penalty = Math.round(baseReward * penaltyPercent);
                                                
                                                if (state.hasUsedBoost && state.confidenceMultiplier > 1) {
                                                    return `<p class="font-bold text-lg">âœ— Wrong! <span class="text-red-700">-${penalty} tokens</span></p><p class="text-sm mt-2 text-red-600">Lost ${state.confidenceMultiplier}x multiplier AND penalty applied</p>`;
                                                } else {
                                                    return `<p class="font-bold text-lg">âœ— Wrong! <span class="text-red-700">-${penalty} tokens</span></p><p class="text-sm mt-2 text-gray-600">Level ${state.difficulty} penalty: ${Math.round(penaltyPercent * 100)}% of base reward</p>`;
                                                }
                                            }
                                        })()}
                                    </div>
                                    <div class="bg-blue-50 p-4 rounded-lg border-2 border-blue-300 mb-4">
                                        <h4 class="font-bold text-blue-900 mb-3">Explanation:</h4>
                                        <div class="text-gray-800">${card.explanation}</div>
                                    </div>
                                    
                                    <button onclick="handleNext()" 
                                        class="w-full py-3 bg-gradient-to-r from-green-600 to-blue-600 text-white rounded-lg font-semibold text-lg mb-4">
                                        ${state.currentCard < totalCards ? `Next Card (${state.currentCard + 1} of ${totalCards})` : 'Next Scenario'}
                                    </button>
                                    
                                    <div class="p-4 bg-purple-50 border-2 border-purple-300 rounded-lg">
                                        <h4 class="font-bold text-purple-900 mb-3 flex items-center gap-2">
                                            ðŸ’¬ Ask AI About This Scenario
                                        </h4>
                                        <div class="flex gap-2 mb-3">
                                            <input type="text" id="aiQuestion" value="This feature is coming soon!" 
                                                placeholder="This feature is coming soon!" 
                                                class="flex-1 p-3 border-2 border-purple-200 rounded-lg"
                                                disabled>
                                            <button disabled
                                                class="px-6 py-3 bg-gray-400 text-white rounded-lg font-semibold cursor-not-allowed">
                                                Coming Soon
                                            </button>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add level modal overlay if open
            if (state.showLevelModal) {
                app.innerHTML += `
                    <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onclick="closeLevelModal()">
                        <div class="bg-white rounded-2xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-y-auto p-8" onclick="event.stopPropagation()">
                            <div class="flex justify-between items-center mb-6">
                                <h2 class="text-3xl font-bold bg-gradient-to-r from-green-600 to-blue-600 bg-clip-text text-transparent">
                                    Select Difficulty Level
                                </h2>
                                <button onclick="closeLevelModal()" class="text-gray-500 hover:text-gray-700 text-3xl font-bold">Ã—</button>
                            </div>
                            <p class="text-gray-600 mb-6">Change will apply after completing current scenario</p>
                            
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                ${difficultyLevels.map(level => `
                                    <div class="border-2 ${state.difficulty === level.level ? 'border-blue-500 bg-blue-50' : 'border-gray-300'} rounded-xl p-6 cursor-pointer hover:shadow-lg transition-all"
                                        onclick="selectLevel(${level.level}); closeLevelModal();">
                                        <div class="flex items-start justify-between mb-3">
                                            <div>
                                                <h3 class="text-xl font-bold text-gray-900">Level ${level.level}: ${level.name}</h3>
                                                <p class="text-sm text-gray-600 mt-1">${level.description}</p>
                                            </div>
                                            <span class="bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm font-semibold">
                                                +${level.baseReward} tokens
                                            </span>
                                        </div>
                                        
                                        <div class="bg-gray-50 rounded-lg p-4 mb-3">
                                            <p class="text-sm text-gray-700">${level.details}</p>
                                        </div>
                                        
                                        <div class="flex gap-4 text-sm">
                                            <div class="flex items-center gap-2">
                                                <span class="text-gray-600">Cards:</span>
                                                <span class="font-semibold">${level.cards}</span>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <span class="text-gray-600">Reward:</span>
                                                <span class="font-semibold text-green-600">+${level.baseReward}</span>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <span class="text-gray-600">Penalty:</span>
                                                <span class="font-semibold text-red-600">-${Math.round(level.baseReward * (0.25 + (level.level - 1) * (0.75 / 9)))}</span>
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Tutorial Modal - only show when in game view (not level select or auth)
            if (state.showTutorial && !state.showAuth && !state.showLevelSelect && state.currentScenarioData) {
                const tutorialContent = getTutorialContent(state.tutorialLevel);
                app.innerHTML += `
                    <div class="tutorial-modal" onclick="closeTutorial()">
                        <div class="tutorial-content" onclick="event.stopPropagation()">
                            <div class="flex justify-between items-start mb-6">
                                <h2 class="text-3xl font-bold" style="color: var(--augusta-green);">
                                    ðŸ“š ${tutorialContent.title}
                                </h2>
                                <button onclick="closeTutorial()" class="text-gray-500 hover:text-gray-700 text-4xl font-bold leading-none">Ã—</button>
                            </div>
                            <div class="text-gray-700 space-y-4">
                                ${tutorialContent.content}
                            </div>
                            <div class="mt-6 pt-6 border-t border-gray-200 flex justify-end">
                                <button onclick="closeTutorial()" class="px-6 py-3 rounded-lg font-semibold text-white" style="background: var(--augusta-green);">
                                    Got it! ðŸ‘
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Level-Up Promotion Modal
            if (state.showLevelUpPromotion) {
                const nextLevel = state.promotionTargetLevel;
                const levelInfo = difficultyLevels[nextLevel - 1];
                const currentPerf = state.levelPerformance[state.difficulty];
                const overallAcc = Math.round((currentPerf.correct / currentPerf.total) * 100);
                
                app.innerHTML += `
                    <div class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
                        <div class="bg-gradient-to-br from-yellow-50 to-orange-50 rounded-2xl shadow-2xl max-w-lg w-full p-8 border-4 border-yellow-400">
                            <div class="text-center mb-6">
                                <div class="text-6xl mb-4">ðŸŽ¯</div>
                                <h2 class="text-3xl font-bold mb-2" style="color: var(--augusta-green);">
                                    You're Ready to Level Up!
                                </h2>
                                <p class="text-gray-600 text-lg">
                                    You're crushing Level ${state.difficulty}!
                                </p>
                            </div>
                            
                            <div class="bg-white rounded-lg p-5 mb-6 shadow-inner">
                                <h3 class="font-bold text-lg mb-3 text-center text-gray-800">Your Performance:</h3>
                                <div class="grid grid-cols-2 gap-4 text-center">
                                    <div class="bg-green-50 rounded-lg p-3">
                                        <div class="text-3xl font-bold text-green-600">${currentPerf.scenarios}</div>
                                        <div class="text-sm text-gray-600">Scenarios</div>
                                    </div>
                                    <div class="bg-blue-50 rounded-lg p-3">
                                        <div class="text-3xl font-bold text-blue-600">${overallAcc}%</div>
                                        <div class="text-sm text-gray-600">Accuracy</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="bg-gradient-to-r from-green-50 to-blue-50 rounded-lg p-5 mb-6 border-2 border-green-200">
                                <h3 class="font-bold text-lg mb-2 text-center">Ready for Level ${nextLevel}:</h3>
                                <p class="text-center font-bold text-xl mb-2" style="color: var(--augusta-green);">${levelInfo.name}</p>
                                <p class="text-center text-gray-600 text-sm">${levelInfo.description}</p>
                                <p class="text-center text-sm mt-3 text-gray-500">${levelInfo.details}</p>
                            </div>
                            
                            <div class="flex gap-3">
                                <button onclick="declinePromotion()" class="flex-1 py-3 px-4 bg-gray-300 text-gray-700 rounded-lg font-semibold hover:bg-gray-400 transition">
                                    Not Yet
                                </button>
                                <button onclick="acceptPromotion()" class="flex-1 py-3 px-4 bg-gradient-to-r from-green-600 to-blue-600 text-white rounded-lg font-semibold hover:from-green-700 hover:to-blue-700 transition">
                                    Level Up! ðŸš€
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Add event listener for AI question input
            if (state.showExplanation) {
                const aiInput = document.getElementById('aiQuestion');
                if (aiInput) {
                    aiInput.addEventListener('input', e => {
                        state.aiQuestion = e.target.value;
                    });
                }
            }
        }

        function handleLogin() {
            if (state.username.trim()) {
                state.user = {
                    name: state.username,
                    tokens: 100,
                    questionsAnswered: 0,
                    correctAnswers: 0,
                    currentStreak: 0,
                    bestStreak: 0
                };
                state.showAuth = false;
                state.showLevelSelect = true;
                render();
            }
        }

        function handleAnswer(answer) {
            // Hide confidence boost countdown once answer is selected
            if (state.showConfidenceBoost) {
                state.showConfidenceBoost = false;
                if (state.boostTimer) {
                    clearInterval(state.boostTimer);
                    state.boostTimer = null;
                }
            }
            
            state.selectedAnswer = answer;
            const card = state.currentScenarioData.cards[state.currentCard - 1];
            state.isCorrect = answer === card.correct;
            state.showExplanation = true;
            
            // Track boost progress if active
            if (state.hasUsedBoost && !state.boostLost) {
                state.boostCardResults.push(state.isCorrect);
                if (!state.isCorrect) {
                    state.boostLost = true;
                }
            }
            
            render();
        }

        function handleNext() {
            const totalCards = difficultyLevels[state.difficulty - 1].cards;
            const baseReward = difficultyLevels[state.difficulty - 1].baseReward;
            
            // Determine if boost applies (only on last card of scenario)
            let multiplier = 1;
            let allCardsCorrect = false;
            
            if (state.currentCard >= totalCards && state.hasUsedBoost) {
                // Check if ALL cards were correct
                allCardsCorrect = state.boostCardResults.every(result => result === true) && state.boostCardResults.length === totalCards;
                if (allCardsCorrect && !state.boostLost) {
                    multiplier = state.confidenceMultiplier;
                }
            }
            
            // Calculate reward or penalty
            let reward = 0;
            if (state.isCorrect) {
                reward = baseReward * multiplier;
            } else {
                // Progressive penalty: 25% at level 1, scaling to 100% at level 10
                const penaltyPercent = 0.25 + (state.difficulty - 1) * (0.75 / 9);
                reward = -Math.round(baseReward * penaltyPercent);
            }
            
            state.user.tokens = Math.max(0, state.user.tokens + reward);
            state.user.questionsAnswered++;
            state.user.correctAnswers += state.isCorrect ? 1 : 0;
            state.user.currentStreak = state.isCorrect ? state.user.currentStreak + 1 : 0;
            
            // Update best streak
            if (state.user.currentStreak > state.user.bestStreak) {
                state.user.bestStreak = state.user.currentStreak;
            }
            
            if (state.isCorrect) {
                saveScore();
            }
            
            if (state.currentCard < totalCards) {
                state.currentCard++;
            } else {
                // Scenario complete - track performance
                const scenarioCorrect = state.boostCardResults.filter(r => r).length;
                const scenarioTotal = state.boostCardResults.length;
                trackLevelPerformance(state.difficulty, scenarioCorrect, scenarioTotal);
                
                // Check for level-up promotion
                if (checkLevelPromotion(state.difficulty)) {
                    showLevelUpPromotion(state.difficulty + 1);
                }
                
                state.scenarioNumber++;
                state.currentCard = 1;
                state.currentScenarioData = generateScenario(state.difficulty);
                // Reset boost tracking for new scenario
                state.confidenceMultiplier = 1;
                state.hasUsedBoost = false;
                state.boostCardResults = [];
                state.boostLost = false;
                // Potentially show confidence boost for next scenario
                maybeShowConfidenceBoost();
            }
            
            state.selectedAnswer = null;
            state.showExplanation = false;
            state.isCorrect = null;
            render();
        }

        async function handleAskAI() {
            if (!state.aiQuestion || !state.aiQuestion.trim() || !state.currentScenarioData) return;
            
            state.isAskingAI = true;
            render();
            
            try {
                const card = state.currentScenarioData.cards[state.currentCard - 1];
                const dataStr = Object.entries(state.currentScenarioData.data)
                    .map(([key, value]) => key + ": " + value)
                    .join('\n');
                
                const response = await fetch("https://api.anthropic.com/v1/messages", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        model: "claude-sonnet-4-20250514",
                        max_tokens: 1000,
                        messages: [{
                            role: "user",
                            content: `You are a golf physics expert helping a student understand ball flight. Here is the current scenario data:\n\n${dataStr}\n\nCurrent Question: ${card.question}\n\nStudent's Question: ${state.aiQuestion}\n\nProvide a helpful, educational response that explains the physics concepts without directly giving away the answer. Help them understand how to think about the problem.`
                        }],
                    })
                });

                const data = await response.json();
                const aiText = data.content?.find(item => item.type === "text")?.text || "I couldn't generate a response. Please try again.";
                state.aiResponse = aiText;
            } catch (error) {
                state.aiResponse = "Sorry, I encountered an error. The AI feature requires an API key to work when self-hosted.";
            } finally {
                state.isAskingAI = false;
                render();
            }
        }

        function toggleDifficulty() {
            state.showLevelModal = !state.showLevelModal;
            render();
        }

        function closeLevelModal() {
            state.showLevelModal = false;
            render();
        }

        function changeDifficulty(level) {
            state.difficulty = parseInt(level);
            state.currentScenarioData = generateScenario(state.difficulty);
            state.currentCard = 1;
            state.scenarioNumber = 1;
            state.selectedAnswer = null;
            state.showExplanation = false;
            render();
        }

        // Initial render
        render();
    </script>
</body>
</html>
