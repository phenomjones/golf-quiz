
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Flight Master</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --augusta-green: #006747;
            --augusta-dark: #004d35;
            --masters-gold: #D4AF37;
        }
        
        body { 
            margin: 0; 
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        .hint-fade { 
            color: #9ca3af; 
            font-size: 0.875rem; 
            opacity: 0.7;
            font-style: italic;
        }
        
        .golf-bg {
            background: var(--bg-image);
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            position: relative;
            min-height: 100vh;
        }
        
        .golf-bg::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 0;
        }
        
        .golf-bg > * {
            position: relative;
            z-index: 1;
        }
        
        .shot-description {
            font-size: 0.875rem;
            color: #6b7280;
            font-style: italic;
            margin-top: 0.25rem;
        }
    </style>
    <script>
        // Rotating golf course backgrounds from Pexels
        const golfBackgrounds = [
            'https://images.pexels.com/photos/914682/pexels-photo-914682.jpeg?auto=compress&cs=tinysrgb&w=1920', // Fairway view
            'https://images.pexels.com/photos/1325667/pexels-photo-1325667.jpeg?auto=compress&cs=tinysrgb&w=1920', // Green with flag
            'https://images.pexels.com/photos/1409068/pexels-photo-1409068.jpeg?auto=compress&cs=tinysrgb&w=1920', // Aerial course
            'https://images.pexels.com/photos/1325735/pexels-photo-1325735.jpeg?auto=compress&cs=tinysrgb&w=1920', // Golf course landscape
            'https://images.pexels.com/photos/424729/pexels-photo-424729.jpeg?auto=compress&cs=tinysrgb&w=1920'  // Tee box
        ];
        const selectedBg = golfBackgrounds[Math.floor(Math.random() * golfBackgrounds.length)];
        
        // Set background with brighter green gradient fallback (Augusta-inspired)
        document.documentElement.style.setProperty('--bg-image', 
            `linear-gradient(135deg, #2d7a4f 0%, #1a5c3f 25%, #0f4229 50%, #1a5c3f 75%, #2d7a4f 100%), url('${selectedBg}')`
        );
    </script>
</head>
<body>
    <div id="app"></div>
    <script>
        // Simple state management
        let state = {
            user: null,
            showAuth: true,
            showLevelSelect: false,
            username: '',
            scenarioNumber: 1,
            currentCard: 1,
            selectedAnswer: null,
            showExplanation: false,
            isCorrect: null,
            difficulty: 1,
            showDifficultySelector: false,
            currentScenarioData: null,
            showConfidenceBoost: false,
            confidenceMultiplier: 1,
            hasUsedBoost: false,
            boostCountdown: 20,
            boostTimer: null,
            boostCardResults: [], // Track card results for multi-card scenarios
            boostLost: false,
            showLevelModal: false
        };

        const difficultyLevels = [
            { level: 1, name: "Range Rookie", description: "Learn face-to-path calculation", baseReward: 10, cards: 2, details: "Learn to calculate face-to-path angle and identify basic shot shapes. Full hints provided." },
            { level: 2, name: "Weekend Warrior", description: "Practice fundamentals", baseReward: 15, cards: 2, details: "Reinforce face-to-path calculations with shot shape recognition. 3 answer options." },
            { level: 3, name: "Club Champion", description: "Add start direction", baseReward: 25, cards: 3, details: "Learn which direction the ball starts. Gear effect from heel/toe impacts introduced. 4 answer options." },
            { level: 4, name: "Scratch Golfer", description: "Master the basics", baseReward: 40, cards: 3, details: "Solidify understanding of face-to-path, start direction, and shot shapes. More extreme mishits." },
            { level: 5, name: "Mini-Tour Pro", description: "Mixed question pool", baseReward: 60, cards: 3, details: "Questions randomized from pool: shot shape, start position (in yards), offline distance. 5 answer options." },
            { level: 6, name: "Korn Ferry Player", description: "Advanced concepts", baseReward: 85, cards: 3, details: "New questions: What's the PRIMARY cause? What's the NET curve direction? Hints start fading." },
            { level: 7, name: "PGA Tour Player", description: "No more hints", baseReward: 115, cards: 3, details: "All directional hints removed. New question: Which variable has LEAST impact? Wind conditions added." },
            { level: 8, name: "Tour Winner", description: "Hypothetical scenarios", baseReward: 150, cards: 3, details: "Answer hypothetical questions: 'If you changed the face angle, what would happen?' 6 answer options. Trick scenarios appear (15% chance)." },
            { level: 9, name: "Major Champion", description: "Expert-level analysis", baseReward: 200, cards: 3, details: "All question types in play. Lie conditions (uphill/downhill) affect ball flight. -95% penalty for wrong answers." },
            { level: 10, name: "Masters Champion", description: "Ultimate challenge", baseReward: 300, cards: 3, details: "The pinnacle. All variables, trick scenarios, no hints. Wrong answers cost you the full 300 tokens. Earn your green jacket!" }
        ];

        const shotShapeDescriptions = {
            "Straight": "starts on target, flies straight with minimal curve",
            "Push": "starts right of target, flies straight right",
            "Pull": "starts left of target, flies straight left",
            "Draw": "curves moderately left, consistent predictable shape",
            "Fade": "curves moderately right, consistent predictable shape",
            "Hook": "curves severely left, hard to control",
            "Slice": "curves severely right, hard to control",
            "Push-draw": "starts right, curves back left toward target",
            "Push-fade": "starts right, curves further right",
            "Push-hook": "starts right, curves severely back left",
            "Push-slice": "starts right, curves strongly further right",
            "Pull-draw": "starts left, curves further left",
            "Pull-fade": "starts left, curves back right toward target",
            "Pull-hook": "starts left, curves severely further left",
            "Pull-slice": "starts left, curves strongly back right"
        };

        function generateScenario(diffLevel) {
            let isTrickScenario = false; // Track if this is a trick scenario
            
            const baseClubSpeed = { driver: 105, wood: 95, iron: 85, wedge: 75 };
            const baseCarryDistance = { driver: 250, wood: 220, iron: 165, wedge: 120 };
            const clubs = diffLevel <= 2 ? ["7 Iron"] : 
                         diffLevel <= 5 ? ["Driver", "5 Wood", "7 Iron"] :
                         ["Driver", "3 Wood", "5 Iron", "7 Iron", "PW"];
            const club = clubs[Math.floor(Math.random() * clubs.length)];
            
            const clubType = club.includes("Driver") ? "driver" : 
                             club.includes("Wood") ? "wood" : 
                             club.includes("PW") ? "wedge" : "iron";
            
            // Club-specific physics
            const clubPhysics = {
                driver: { startFaceInfluence: 0.85, curveMultiplier: 6, loft: 10, gearMultiplier: 0.6 },
                wood: { startFaceInfluence: 0.82, curveMultiplier: 5, loft: 18, gearMultiplier: 0.5 },
                iron: { startFaceInfluence: 0.75, curveMultiplier: 4, loft: 34, gearMultiplier: 0.3 },
                wedge: { startFaceInfluence: 0.70, curveMultiplier: 3, loft: 50, gearMultiplier: 0.15 }
            };
            const physics = clubPhysics[clubType];
            
            const speedVariance = diffLevel % 2 === 0 ? 15 : 10;
            
            let speed = baseClubSpeed[clubType] + (Math.random() * speedVariance - speedVariance/2);
            let carry = baseCarryDistance[clubType] + (Math.random() * (speedVariance * 2) - speedVariance);
            
            // Bell curve distribution for angles using Box-Muller transform
            // This creates a normal distribution centered at 0
            function bellCurve(min, max, stdDev) {
                // Box-Muller transform for normal distribution
                let u1 = Math.random();
                let u2 = Math.random();
                let z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                // Scale to desired std deviation and clamp to range
                let value = z * stdDev;
                return Math.max(min, Math.min(max, value));
            }
            
            // Face: bell curve with std dev of 3Â° (most shots within Â±3Â°)
            let face = bellCurve(-11, 11, 3);
            face = parseFloat(face.toFixed(1));
            
            // Path: bell curve with std dev of 3.5Â° (slightly wider than face)
            let path = bellCurve(-11, 11, 3.5);
            path = parseFloat(path.toFixed(1));
            
            let gearEffect = 0; // Will be set if impact location exists
            let windEffect = 0; // Will be set if wind exists
            let windDir = "";
            let impactLocationText = "";
            
            let faceDisplay, pathDisplay;
            
            // Progressive hint removal: levels 1-4 full hints, 5-6 faded, 7+ none
            if (diffLevel <= 4) {
                faceDisplay = face + "Â°" + (face > 0 ? " (right)" : face < 0 ? " (left)" : "");
                pathDisplay = path + "Â°" + (path > 0 ? " (right)" : path < 0 ? " (left)" : "");
            } else if (diffLevel <= 6) {
                // Faded hints with CSS class
                const faceHint = face > 0 ? ' <span class="hint-fade">(right)</span>' : face < 0 ? ' <span class="hint-fade">(left)</span>' : "";
                const pathHint = path > 0 ? ' <span class="hint-fade">(right)</span>' : path < 0 ? ' <span class="hint-fade">(left)</span>' : "";
                faceDisplay = face + "Â°" + faceHint;
                pathDisplay = path + "Â°" + pathHint;
            } else {
                // Levels 7-10: no hints at all
                faceDisplay = face + "Â°";
                pathDisplay = path + "Â°";
            }
            
            // Initialize carry label (will be updated if wind exists)
            let carryLabel = "Club / Club Speed / Carry";
            
            let data = {
                [carryLabel]: {
                    icon: "ðŸŒï¸",
                    label: carryLabel,
                    value: club + " â€¢ " + speed.toFixed(1) + " mph â€¢ " + Math.round(carry) + " yards"
                },
                "Club Face": {
                    icon: "ðŸŽ¯",
                    label: "Club Face",
                    value: faceDisplay
                },
                "Club Path": {
                    icon: "â†ªï¸",
                    label: "Club Path",
                    value: pathDisplay
                }
            };
            
            if (diffLevel >= 3) {
                // Trick scenarios: at high levels, occasionally create strong opposing forces
                const shouldBeTrick = diffLevel >= 8 && Math.random() < 0.15; // 15% chance at levels 8-10
                
                let maxImpact = diffLevel === 3 ? 6 : 12;
                let impact;
                
                if (shouldBeTrick) {
                    isTrickScenario = true; // Mark this as a trick scenario
                    // Force a trick scenario: strong gear effect opposing face-to-path
                    maxImpact = 12;
                    const faceToPath = face - path;
                    // If face-to-path is positive (fade), create strong toe hit (draw gear)
                    // If face-to-path is negative (draw), create strong heel hit (fade gear)
                    if (faceToPath > 0) {
                        impact = Math.random() * 6 + 6; // Strong toe hit (6-12mm)
                    } else if (faceToPath < 0) {
                        impact = -(Math.random() * 6 + 6); // Strong heel hit (-6 to -12mm)
                    } else {
                        impact = Math.random() * maxImpact - maxImpact/2; // Random if straight
                    }
                } else {
                    impact = Math.random() * maxImpact - maxImpact/2;
                }
                
                const impactSide = impact > 0 ? "toe" : "heel";
                data["Impact Location"] = {
                    icon: "ðŸ“",
                    label: "Impact Location",
                    value: Math.abs(impact).toFixed(1) + "mm " + impactSide
                };
                
                // Gear effect: heel creates FADE spin (negative impact = positive gear effect = fade)
                // toe creates DRAW spin (positive impact = negative gear effect = draw)
                gearEffect = impact * -physics.gearMultiplier;
                impactLocationText = Math.abs(impact).toFixed(1) + "mm " + impactSide;
            }
            
            if (diffLevel >= 5) {
                data["Spin Loft"] = {
                    icon: "ðŸ”„",
                    label: "Spin Loft",
                    value: (Math.random() * 8 + 10).toFixed(1) + "Â°"
                };
            }
            
            let windSpeedMPH = 0;
            let windMultiplier = 1.0; // How wind affects spin/curve
            let carryAdjustment = 0; // How wind affects distance
            
            if (diffLevel >= 7) {
                // Bell curve distribution: mean ~7 MPH, std dev ~5, capped at 25
                const bellCurve = () => {
                    const u1 = Math.random();
                    const u2 = Math.random();
                    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    return z * 5 + 7; // std dev 5, mean 7
                };
                windSpeedMPH = Math.max(0, Math.min(25, Math.round(bellCurve())));
                
                const windDirs = ["Headwind", "Tailwind", "Left-to-Right", "Right-to-Left"];
                windDir = windDirs[Math.floor(Math.random() * windDirs.length)];
                
                data["Wind"] = {
                    icon: "ðŸ’¨",
                    label: "Wind",
                    value: windSpeedMPH + " mph " + windDir
                };
                
                // Wind physics
                if (windDir === "Headwind") {
                    carryAdjustment = -windSpeedMPH * 2; // Headwind hurts more
                    windMultiplier = 1.0 + (windSpeedMPH / 100); // Amplifies spin/curve by ~20-30% at strong wind
                } else if (windDir === "Tailwind") {
                    carryAdjustment = windSpeedMPH * 1; // Tailwind helps less
                    windMultiplier = 1.0 - (windSpeedMPH / 150); // Dampens spin/curve by ~15-20% at strong wind
                } else {
                    // Crosswind: lateral push based on speed tier
                    const carryInTens = carry / 10;
                    let yardsPerTen;
                    if (windSpeedMPH <= 10) yardsPerTen = 0.5; // Light
                    else if (windSpeedMPH <= 15) yardsPerTen = 0.75; // Moderate
                    else yardsPerTen = 1.0; // Strong
                    
                    windEffect = (windDir === "Left-to-Right" ? 1 : -1) * yardsPerTen * carryInTens;
                    carryAdjustment = -windSpeedMPH * 0.1; // Slight drag from crosswind
                }
            }
            
            // Apply carry adjustment
            carry = Math.round(carry + carryAdjustment);
            
            // Update carry label if wind affected distance
            if (windSpeedMPH > 0 && carryAdjustment !== 0) {
                carryLabel = "Club / Club Speed / Carry (after wind)";
            }
            
            if (diffLevel >= 9) {
                const lies = ["Flat", "Uphill 3Â°", "Downhill 3Â°", "Ball above feet", "Ball below feet"];
                data["Lie"] = {
                    icon: "â›°ï¸",
                    label: "Lie",
                    value: lies[Math.floor(Math.random() * lies.length)]
                };
            }

            const faceToPath = face - path + gearEffect;
            const startDir = face > 0 ? "right" : face < 0 ? "left" : "straight";
            
            // Determine shape based on tighter thresholds
            const absFTP = Math.abs(faceToPath);
            const curveType = absFTP <= 0.5 ? "straight" : absFTP <= 3.0 ? "moderate" : absFTP <= 6.0 ? "heavy" : "extreme";
            const startType = Math.abs(face) <= 1 ? "straight" : face > 1 ? "push" : "pull";
            const isDrawCurve = faceToPath < 0;
            
            let shape = "Straight";
            let shapeDesc = "on target, no curve";
            
            if (curveType !== "straight") {
                const curveNames = {
                    moderate: isDrawCurve ? ["Draw", "curves moderately left, consistent predictable shape"] : ["Fade", "curves moderately right, consistent predictable shape"],
                    heavy: isDrawCurve ? ["Draw", "curves moderately left, consistent predictable shape"] : ["Fade", "curves moderately right, consistent predictable shape"],
                    extreme: isDrawCurve ? ["Hook", "curves severely left, hard to control"] : ["Slice", "curves severely right, hard to control"]
                };
                
                if (startType === "straight") {
                    [shape, shapeDesc] = curveNames[curveType];
                } else if (startType === "push") {
                    if (curveType === "moderate") [shape, shapeDesc] = isDrawCurve ? ["Push-draw", "starts right, curves back left toward target"] : ["Push-fade", "starts right, curves further right"];
                    else if (curveType === "heavy") [shape, shapeDesc] = isDrawCurve ? ["Push-draw", "starts right, curves back left toward target"] : ["Push-fade", "starts right, curves further right"];
                    else [shape, shapeDesc] = isDrawCurve ? ["Push-hook", "starts right, curves severely back left"] : ["Push-slice", "starts right, curves strongly further right"];
                } else {
                    if (curveType === "moderate" || curveType === "heavy") [shape, shapeDesc] = isDrawCurve ? ["Pull-draw", "starts left, curves further left"] : ["Pull-fade", "starts left, curves back right toward target"];
                    else [shape, shapeDesc] = isDrawCurve ? ["Pull-hook", "starts left, curves severely further left"] : ["Pull-slice", "starts left, curves strongly back right"];
                }
            } else {
                if (startType === "push") [shape, shapeDesc] = ["Push", "starts right of target, flies straight right"];
                else if (startType === "pull") [shape, shapeDesc] = ["Pull", "starts left of target, flies straight left"];
            }

            const cards = [];
            const baseFaceToPath = face - path;
            
            // LEVEL-BASED CARD GENERATION
            if (diffLevel <= 2) {
                // Level 1-2: Teach face-to-path calculation + shot shape
                cards.push(generateFaceToPathQuestion(face, path, diffLevel));
                
                // Then shot shape question
                const allShapes = ["Straight", "Push", "Pull", "Draw", "Fade", "Hook", "Slice", "Push-draw", "Push-fade", "Push-hook", "Push-slice", "Pull-hook", "Pull-fade", "Pull-slice"];
                const numWrongOptions = 2; // 3 total
                const wrongShapes = allShapes.filter(s => s !== shape).sort(() => Math.random() - 0.5).slice(0, numWrongOptions);
                const options = [shape, ...wrongShapes].sort(() => Math.random() - 0.5);
                const optionsWithDescriptions = options.map(o => o + " (" + getShapeDesc(o) + ")");
                
                let explanationParts = [];
                explanationParts.push(`<strong>Club:</strong> ${club} (${physics.loft}Â° loft)`);
                explanationParts.push(`<strong>Face:</strong> ${face}Â°`);
                explanationParts.push(`<strong>Path:</strong> ${path}Â°`);
                explanationParts.push(`<strong>Face-to-path:</strong> ${baseFaceToPath.toFixed(1)}Â°`);
                if (gearEffect !== 0) {
                    const gearDir = gearEffect > 0 ? "fade" : "draw";
                    const gearRelation = (gearEffect > 0 && baseFaceToPath > 0) || (gearEffect < 0 && baseFaceToPath < 0) ? "additional" : "opposing";
                    const highlightClass = gearRelation === "opposing" ? ' style="color: #dc2626; font-weight: bold;"' : '';
                    const warningIcon = gearRelation === "opposing" ? "âš ï¸ " : "";
                    explanationParts.push(`<strong${highlightClass}>${warningIcon}Gear effect (${gearRelation}):</strong> ${impactLocationText} = ${Math.abs(gearEffect).toFixed(1)}Â° ${gearDir} spin`);
                    explanationParts.push(`<strong>Total face-to-path:</strong> ${faceToPath.toFixed(1)}Â° (with gear effect)`);
                }
                explanationParts.push(`<strong>Result:</strong> ${shape} - ${shapeDesc}`);
                
                cards.push({
                    question: "What will be the shot shape?",
                    options: optionsWithDescriptions,
                    correct: shape + " (" + shapeDesc + ")",
                    correctBase: shape,
                    explanation: '<div class="space-y-1">' + explanationParts.map(p => '<div>' + p + '</div>').join('') + '</div>'
                });
                
            } else if (diffLevel <= 4) {
                // Level 3-4: face-to-path + start direction + shot shape
                cards.push(generateFaceToPathQuestion(face, path, diffLevel));
                
                cards.push({
                    question: "Will the ball start left or right of the target?",
                    options: ["Left of target", "Right of target", "Straight at target"],
                    correct: face < -0.5 ? "Left of target" : face > 0.5 ? "Right of target" : "Straight at target",
                    explanation: `<div><strong>Face angle:</strong> ${face}Â°</div><div><strong>Club:</strong> ${club} (${Math.round(physics.startFaceInfluence * 100)}% face influence)</div><div>The ball starts <strong>${startDir}</strong> because face angle controls ${Math.round(physics.startFaceInfluence * 100)}% of initial direction for this club.</div>`
                });
                
                // Shot shape
                const allShapes = ["Straight", "Push", "Pull", "Draw", "Fade", "Hook", "Slice", "Push-draw", "Push-fade", "Push-hook", "Push-slice", "Pull-hook", "Pull-fade", "Pull-slice"];
                const numWrongOptions = 3; // 4 total
                const wrongShapes = allShapes.filter(s => s !== shape).sort(() => Math.random() - 0.5).slice(0, numWrongOptions);
                const options = [shape, ...wrongShapes].sort(() => Math.random() - 0.5);
                const optionsWithDescriptions = options.map(o => o + " (" + getShapeDesc(o) + ")");
                
                let explanationParts = [];
                explanationParts.push(`<strong>Club:</strong> ${club} (${physics.loft}Â° loft)`);
                explanationParts.push(`<strong>Face:</strong> ${face}Â°`);
                explanationParts.push(`<strong>Path:</strong> ${path}Â°`);
                explanationParts.push(`<strong>Face-to-path:</strong> ${baseFaceToPath.toFixed(1)}Â°`);
                if (gearEffect !== 0) {
                    const gearDir = gearEffect > 0 ? "fade" : "draw";
                    const gearRelation = (gearEffect > 0 && baseFaceToPath > 0) || (gearEffect < 0 && baseFaceToPath < 0) ? "additional" : "opposing";
                    const highlightClass = gearRelation === "opposing" ? ' style="color: #dc2626; font-weight: bold;"' : '';
                    const warningIcon = gearRelation === "opposing" ? "âš ï¸ " : "";
                    explanationParts.push(`<strong${highlightClass}>${warningIcon}Gear effect (${gearRelation}):</strong> ${impactLocationText} = ${Math.abs(gearEffect).toFixed(1)}Â° ${gearDir} spin`);
                    explanationParts.push(`<strong>Total face-to-path:</strong> ${faceToPath.toFixed(1)}Â° (with gear effect)`);
                }
                explanationParts.push(`<strong>Result:</strong> ${shape} - ${shapeDesc}`);
                
                cards.push({
                    question: "What will be the shot shape?",
                    options: optionsWithDescriptions,
                    correct: shape + " (" + shapeDesc + ")",
                    correctBase: shape,
                    explanation: '<div class="space-y-1">' + explanationParts.map(p => '<div>' + p + '</div>').join('') + '</div>'
                });
                
            } else {
                // Level 5+: Mix of questions, progressively harder
                const questionPool = [];
                
                // Shot shape (always available)
                const allShapes = ["Straight", "Push", "Pull", "Draw", "Fade", "Hook", "Slice", "Push-draw", "Push-fade", "Push-hook", "Push-slice", "Pull-hook", "Pull-fade", "Pull-slice"];
                
                // Determine number of options: 1-3=3, 4-6=4, 7-9=5, 10=6
                let numWrongOptions;
                if (diffLevel <= 3) numWrongOptions = 2; // 3 total options
                else if (diffLevel <= 6) numWrongOptions = 3; // 4 total options
                else if (diffLevel <= 9) numWrongOptions = 4; // 5 total options
                else numWrongOptions = 5; // 6 total options (level 10)
                
                const wrongShapes = allShapes.filter(s => s !== shape).sort(() => Math.random() - 0.5).slice(0, numWrongOptions);
                const options = [shape, ...wrongShapes].sort(() => Math.random() - 0.5);
                const optionsWithDescriptions = options.map(o => o + " (" + getShapeDesc(o) + ")");
                
                let explanationParts = [];
                explanationParts.push(`<strong>Club:</strong> ${club} (${physics.loft}Â° loft)`);
                explanationParts.push(`<strong>Face:</strong> ${face}Â°`);
                explanationParts.push(`<strong>Path:</strong> ${path}Â°`);
                explanationParts.push(`<strong>Face-to-path:</strong> ${baseFaceToPath.toFixed(1)}Â°`);
                if (gearEffect !== 0) {
                    const gearDir = gearEffect > 0 ? "fade" : "draw";
                    const gearRelation = (gearEffect > 0 && baseFaceToPath > 0) || (gearEffect < 0 && baseFaceToPath < 0) ? "additional" : "opposing";
                    const highlightClass = gearRelation === "opposing" ? ' style="color: #dc2626; font-weight: bold;"' : '';
                    const warningIcon = gearRelation === "opposing" ? "âš ï¸ " : "";
                    explanationParts.push(`<strong${highlightClass}>${warningIcon}Gear effect (${gearRelation}):</strong> ${impactLocationText} = ${Math.abs(gearEffect).toFixed(1)}Â° ${gearDir} spin`);
                    explanationParts.push(`<strong>Total face-to-path:</strong> ${faceToPath.toFixed(1)}Â° (with gear effect)`);
                }
                explanationParts.push(`<strong>Result:</strong> ${shape} - ${shapeDesc}`);
                
                questionPool.push({
                    question: "What will be the shot shape?",
                    options: optionsWithDescriptions,
                    correct: shape + " (" + shapeDesc + ")",
                    correctBase: shape,
                    explanation: '<div class="space-y-1">' + explanationParts.map(p => '<div>' + p + '</div>').join('') + '</div>'
                });
                
                // Start position in yards (Level 5+)
                questionPool.push(generateStartPositionQuestion(face, physics, diffLevel));
                
                // Start direction (Level 5+)
                questionPool.push({
                    question: "Will the ball start left or right of the target?",
                    options: ["Left of target", "Right of target", "Straight at target"],
                    correct: face < -0.5 ? "Left of target" : face > 0.5 ? "Right of target" : "Straight at target",
                    explanation: `<div><strong>Face angle:</strong> ${face}Â°</div><div><strong>Club:</strong> ${club} (${Math.round(physics.startFaceInfluence * 100)}% face influence)</div><div>The ball starts <strong>${startDir}</strong> because face angle controls ${Math.round(physics.startFaceInfluence * 100)}% of initial direction for this club.</div>`
                });
                
                // Advanced questions for level 6+
                if (diffLevel >= 6) {
                    questionPool.push(generatePrimaryCauseQuestion(face, path, gearEffect, windEffect, diffLevel));
                    questionPool.push(generateNetCurveQuestion(baseFaceToPath, gearEffect, windEffect, diffLevel));
                }
                
                // Advanced questions for level 7-10
                if (diffLevel >= 7) {
                    questionPool.push(generateLeastImpactQuestion(face, path, gearEffect, windEffect, diffLevel));
                }
                
                if (diffLevel >= 8) {
                    // Will add hypothetical after we calculate faceContribution and curveContribution below
                }
                
                // Offline distance (Level 5+) - always include
                // Calculate components with club-specific physics
                const faceContribution = face * 3; // Keep sign - positive = right, negative = left
                const baseCurveContribution = baseFaceToPath * physics.curveMultiplier * windMultiplier; // Wind affects spin/curve
                const gearContribution = gearEffect * physics.curveMultiplier * windMultiplier; // Gear effect also affected by wind
                const curveContribution = baseCurveContribution + gearContribution; // Total curve
                
                // Add hypothetical question now that we have the values
                if (diffLevel >= 8) {
                    questionPool.push(generateHypotheticalQuestion(face, path, faceContribution, curveContribution, windEffect, diffLevel));
                }
                
                // Net offline is: where it starts (face) + how much it curves (total)
                const netOffline = faceContribution + curveContribution + windEffect;
                const offlineYards = Math.abs(netOffline);
                const roundedYards = Math.round(offlineYards);
                const offlineDir = netOffline > 0 ? "right" : "left";
                
                let opts, corr;
                
                if (diffLevel <= 6) {
                    // 7-yard ranges
                    opts = [
                        `0-6 yards ${offlineDir}`,
                        `7-13 yards ${offlineDir}`,
                        `14-20 yards ${offlineDir}`,
                        `21-27 yards ${offlineDir}`,
                        `28-34 yards ${offlineDir}`,
                        `35+ yards ${offlineDir}`
                    ];
                    corr = roundedYards <= 6 ? opts[0] : roundedYards <= 13 ? opts[1] : roundedYards <= 20 ? opts[2] : roundedYards <= 27 ? opts[3] : roundedYards <= 34 ? opts[4] : opts[5];
                } else if (diffLevel <= 8) {
                    // 5-yard ranges
                    opts = [
                        `0-4 yards ${offlineDir}`,
                        `5-9 yards ${offlineDir}`,
                        `10-14 yards ${offlineDir}`,
                        `15-19 yards ${offlineDir}`,
                        `20-24 yards ${offlineDir}`,
                        `25+ yards ${offlineDir}`
                    ];
                    corr = roundedYards <= 4 ? opts[0] : roundedYards <= 9 ? opts[1] : roundedYards <= 14 ? opts[2] : roundedYards <= 19 ? opts[3] : roundedYards <= 24 ? opts[4] : opts[5];
                } else {
                    // 3-yard ranges for level 9-10
                    opts = [
                        `0-2 yards ${offlineDir}`,
                        `3-5 yards ${offlineDir}`,
                        `6-8 yards ${offlineDir}`,
                        `9-11 yards ${offlineDir}`,
                        `12-14 yards ${offlineDir}`,
                        `15+ yards ${offlineDir}`
                    ];
                    corr = roundedYards <= 2 ? opts[0] : roundedYards <= 5 ? opts[1] : roundedYards <= 8 ? opts[2] : roundedYards <= 11 ? opts[3] : roundedYards <= 14 ? opts[4] : opts[5];
                }
                
                // Build detailed calculation explanation
                // baseFaceToPath already calculated above
                let calcParts = [];
                
                // Show start position from face (keep precision)
                const faceDir = faceContribution > 0 ? "right" : "left";
                const faceYards = Math.abs(faceContribution);
                calcParts.push(`<strong>Start direction (face):</strong> ${face}Â° = ${faceYards.toFixed(1)} yards ${faceDir}`);
                
                // Show base curve from face-to-path (keep precision)
                const baseFTPDir = baseFaceToPath < 0 ? "draw" : "fade";
                const baseFTPYards = Math.abs(baseCurveContribution);
                const baseFTPSign = baseFaceToPath < 0 ? "left" : "right";
                calcParts.push(`<strong>Face-to-path curve:</strong> ${baseFaceToPath.toFixed(1)}Â° ${baseFTPDir} = ${baseFTPYards.toFixed(1)} yards ${baseFTPSign}`);
                
                // Show gear effect if present (keep precision)
                if (gearEffect !== 0) {
                    const gearDir = gearEffect > 0 ? "fade" : "draw";
                    const gearYards = Math.abs(gearContribution);
                    const gearSign = gearEffect > 0 ? "right" : "left";
                    const gearRelation = (gearEffect > 0 && baseFaceToPath > 0) || (gearEffect < 0 && baseFaceToPath < 0) ? "additional" : "opposing";
                    const highlightClass = gearRelation === "opposing" ? ' style="color: #dc2626; font-weight: bold;"' : '';
                    const warningIcon = gearRelation === "opposing" ? "âš ï¸ " : "";
                    calcParts.push(`<strong${highlightClass}>${warningIcon}Gear effect (${gearRelation}):</strong> ${impactLocationText} creates ${Math.abs(gearEffect).toFixed(1)}Â° ${gearDir} spin = ${gearYards.toFixed(1)} yards ${gearSign}`);
                }
                
                // Show wind if present (keep precision)
                if (windEffect !== 0) {
                    const windSign = windEffect > 0 ? "right" : "left";
                    const windYards = Math.abs(windEffect);
                    calcParts.push(`<strong>Wind:</strong> ${windDir} = ${windYards.toFixed(1)} yards ${windSign}`);
                }
                
                // Show net calculation with ALL THREE components separately
                let netCalcParts = [];
                netCalcParts.push(`${faceContribution > 0 ? '+' : ''}${faceContribution.toFixed(1)} ${faceContribution > 0 ? 'right' : 'left'}`);
                netCalcParts.push(`${baseCurveContribution > 0 ? '+' : ''}${baseCurveContribution.toFixed(1)} ${baseCurveContribution > 0 ? 'right' : 'left'}`);
                
                if (gearEffect !== 0) {
                    netCalcParts.push(`${gearContribution > 0 ? '+' : ''}${gearContribution.toFixed(1)} ${gearContribution > 0 ? 'right' : 'left'}`);
                }
                
                if (windEffect !== 0) {
                    netCalcParts.push(`${windEffect > 0 ? '+' : ''}${windEffect.toFixed(1)} ${windEffect > 0 ? 'right' : 'left'}`);
                }
                
                const netCalc = netCalcParts.join(' ') + ` = ${netOffline.toFixed(1)} yards`;
                
                calcParts.push(`<strong>Net calculation:</strong> ${netCalc}`);
                calcParts.push(`<strong>Final result:</strong> ${roundedYards} yards ${offlineDir}`);
                
                questionPool.push({
                    question: "How far offline will the ball finish from the target?",
                    options: opts,
                    correct: corr,
                    explanation: '<div class="space-y-1">' + calcParts.map(p => '<div>' + p + '</div>').join('') + '</div>'
                });
                
                // Select questions from pool based on number of cards for this level
                const numCards = difficultyLevels[diffLevel - 1].cards;
                const selectedQuestions = questionPool.sort(() => Math.random() - 0.5).slice(0, numCards);
                selectedQuestions.forEach(q => cards.push(q));
            }
            
            return { data, cards, isTrickScenario };
        }

        function getShapeDesc(name) {
            const descs = {
                "Straight": "starts on target, flies straight with minimal curve", 
                "Push": "starts right of target, flies straight right", 
                "Pull": "starts left of target, flies straight left",
                "Draw": "curves moderately left, consistent predictable shape", 
                "Fade": "curves moderately right, consistent predictable shape",
                "Hook": "curves severely left, hard to control", 
                "Slice": "curves severely right, hard to control",
                "Push-draw": "starts right, curves back left toward target", 
                "Push-fade": "starts right, curves further right",
                "Push-hook": "starts right, curves severely back left", 
                "Push-slice": "starts right, curves strongly further right",
                "Pull-draw": "starts left, curves further left",
                "Pull-fade": "starts left, curves back right toward target",
                "Pull-hook": "starts left, curves severely further left", 
                "Pull-slice": "starts left, curves strongly back right"
            };
            return descs[name] || "";
        }

        function generateFaceToPathQuestion(face, path, diffLevel) {
            const correctAnswer = face - path;
            const numOptions = diffLevel <= 3 ? 3 : diffLevel <= 6 ? 4 : diffLevel <= 9 ? 5 : 6;
            
            // Generate wrong answers nearby the correct one
            let options = [correctAnswer];
            const possibleWrong = [
                correctAnswer + 1, correctAnswer - 1,
                correctAnswer + 2, correctAnswer - 2,
                correctAnswer + 3, correctAnswer - 3,
                face + path, // Common mistake: adding instead of subtracting
                path - face  // Common mistake: reversing the subtraction
            ].filter(val => val !== correctAnswer);
            
            // Shuffle and take needed number of wrong answers
            const wrongAnswers = possibleWrong.sort(() => Math.random() - 0.5).slice(0, numOptions - 1);
            options.push(...wrongAnswers);
            options = options.sort(() => Math.random() - 0.5);
            
            return {
                question: "What is the face-to-path angle?",
                options: options.map(o => o.toFixed(1) + "Â°"),
                correct: correctAnswer.toFixed(1) + "Â°",
                explanation: `<div><strong>Calculation:</strong> Face-to-path = Face - Path</div><div>${face.toFixed(1)}Â° - (${path.toFixed(1)}Â°) = ${correctAnswer.toFixed(1)}Â°</div>`
            };
        }

        function generateStartPositionQuestion(face, physics, diffLevel) {
            // Ball starts approximately 3 yards per degree of face angle
            const startYards = face * 3;
            const numOptions = diffLevel <= 3 ? 3 : diffLevel <= 6 ? 4 : diffLevel <= 9 ? 5 : 6;
            
            // Create ranges
            let correctRange;
            if (Math.abs(startYards) <= 2) {
                correctRange = "Straight at target";
            } else if (startYards > 0) {
                if (startYards <= 5) correctRange = "0-2 yards right";
                else if (startYards <= 8) correctRange = "3-5 yards right";
                else if (startYards <= 12) correctRange = "6-8 yards right";
                else correctRange = "9+ yards right";
            } else {
                if (startYards >= -5) correctRange = "0-2 yards left";
                else if (startYards >= -8) correctRange = "3-5 yards left";
                else if (startYards >= -12) correctRange = "6-8 yards left";
                else correctRange = "9+ yards left";
            }
            
            const allOptions = [
                "Straight at target",
                "0-2 yards right", "3-5 yards right", "6-8 yards right", "9+ yards right",
                "0-2 yards left", "3-5 yards left", "6-8 yards left", "9+ yards left"
            ];
            
            // Get wrong answers
            const wrongOptions = allOptions.filter(o => o !== correctRange).sort(() => Math.random() - 0.5).slice(0, numOptions - 1);
            const options = [correctRange, ...wrongOptions].sort(() => Math.random() - 0.5);
            
            return {
                question: "Where will the ball start?",
                options: options,
                correct: correctRange,
                explanation: `<div><strong>Face angle:</strong> ${face.toFixed(1)}Â°</div><div><strong>Start distance:</strong> ${Math.abs(startYards).toFixed(1)} yards ${startYards > 0 ? 'right' : 'left'}</div><div>Face angle controls ${Math.round(physics.startFaceInfluence * 100)}% of start direction (~3 yards per degree)</div>`
            };
        }

        function generatePrimaryCauseQuestion(face, path, gearEffect, windEffect, diffLevel) {
            const baseFaceToPath = face - path;
            const faceContribution = Math.abs(face * 3);
            const pathContribution = Math.abs(baseFaceToPath * 5);
            const gearContribution = Math.abs(gearEffect * 5);
            const windContribution = Math.abs(windEffect);
            
            // Find primary cause
            const causes = [
                { name: "Face angle", value: faceContribution },
                { name: "Face-to-path", value: pathContribution },
                { name: "Gear effect", value: gearContribution },
                { name: "Wind", value: windContribution }
            ];
            causes.sort((a, b) => b.value - a.value);
            
            const numOptions = diffLevel <= 9 ? 5 : 6;
            const options = causes.slice(0, numOptions).map(c => c.name).sort(() => Math.random() - 0.5);
            
            return {
                question: "What is the PRIMARY cause of the ball's final position?",
                options: options,
                correct: causes[0].name,
                explanation: `<div><strong>${causes[0].name}</strong> has the biggest impact with ~${Math.round(causes[0].value)} yards of influence</div><div class="text-sm text-gray-600 mt-2">Others: ${causes.slice(1).map(c => c.name + ' ~' + Math.round(c.value) + 'yds').join(', ')}</div>`
            };
        }

        function generateNetCurveQuestion(baseFaceToPath, gearEffect, windEffect, diffLevel) {
            const totalCurve = baseFaceToPath + gearEffect + (windEffect / 5); // Wind has less effect on curve
            const netDirection = totalCurve < -0.5 ? "Draw (left)" : totalCurve > 0.5 ? "Fade (right)" : "Straight";
            
            const numOptions = diffLevel <= 9 ? 5 : 6;
            const allOptions = ["Draw (left)", "Fade (right)", "Straight", "Hook (left)", "Slice (right)"];
            const wrongOptions = allOptions.filter(o => o !== netDirection).sort(() => Math.random() - 0.5).slice(0, numOptions - 1);
            const options = [netDirection, ...wrongOptions].sort(() => Math.random() - 0.5);
            
            return {
                question: "After accounting for ALL factors, will the ball curve left or right?",
                options: options,
                correct: netDirection,
                explanation: `<div><strong>Base face-to-path:</strong> ${baseFaceToPath.toFixed(1)}Â°</div><div><strong>Gear effect:</strong> ${gearEffect > 0 ? '+' : ''}${gearEffect.toFixed(1)}Â°</div><div><strong>Wind influence:</strong> ${(windEffect / 5).toFixed(1)}Â°</div><div class="mt-2"><strong>Net curve:</strong> ${totalCurve.toFixed(1)}Â° = ${netDirection}</div>`
            };
        }

        function generateHypotheticalQuestion(face, path, faceContribution, curveContribution, windEffect, diffLevel) {
            // What if face was 2Â° more closed?
            const newFace = face - 2;
            const newFaceContribution = newFace * 3;
            const newNetOffline = newFaceContribution + curveContribution + windEffect;
            const newRoundedYards = Math.round(Math.abs(newNetOffline));
            const newDir = newNetOffline > 0 ? "right" : "left";
            
            const numOptions = diffLevel <= 9 ? 5 : 6;
            let correctRange;
            if (newRoundedYards <= 6) correctRange = `0-6 yards ${newDir}`;
            else if (newRoundedYards <= 13) correctRange = `7-13 yards ${newDir}`;
            else if (newRoundedYards <= 20) correctRange = `14-20 yards ${newDir}`;
            else if (newRoundedYards <= 27) correctRange = `21-27 yards ${newDir}`;
            else correctRange = `28+ yards ${newDir}`;
            
            const allOptions = [
                "0-6 yards left", "7-13 yards left", "14-20 yards left", "21-27 yards left", "28+ yards left",
                "0-6 yards right", "7-13 yards right", "14-20 yards right", "21-27 yards right", "28+ yards right"
            ];
            const wrongOptions = allOptions.filter(o => o !== correctRange).sort(() => Math.random() - 0.5).slice(0, numOptions - 1);
            const options = [correctRange, ...wrongOptions].sort(() => Math.random() - 0.5);
            
            return {
                question: "If you CLOSED the face by 2Â° (keeping path the same), where would the ball finish?",
                options: options,
                correct: correctRange,
                explanation: `<div><strong>Original face:</strong> ${face.toFixed(1)}Â°</div><div><strong>New face:</strong> ${newFace.toFixed(1)}Â°</div><div><strong>New start direction:</strong> ${Math.abs(newFaceContribution).toFixed(1)} yards ${newFaceContribution > 0 ? 'right' : 'left'}</div><div><strong>Curve stays the same:</strong> ${Math.abs(curveContribution).toFixed(1)} yards</div><div><strong>New final position:</strong> ${newRoundedYards} yards ${newDir}</div>`
            };
        }

        function generateLeastImpactQuestion(face, path, gearEffect, windEffect, diffLevel) {
            const faceContribution = Math.abs(face * 3);
            const pathContribution = Math.abs((face - path) * 5);
            const gearContribution = Math.abs(gearEffect * 5);
            const windContribution = Math.abs(windEffect);
            
            // Find LEAST impact
            const causes = [
                { name: "Face angle", value: faceContribution },
                { name: "Face-to-path", value: pathContribution },
                { name: "Gear effect", value: gearContribution },
                { name: "Wind", value: windContribution }
            ];
            causes.sort((a, b) => a.value - b.value); // Sort ascending - least first
            
            const numOptions = diffLevel <= 9 ? 5 : 6;
            const options = causes.slice(0, numOptions).map(c => c.name).sort(() => Math.random() - 0.5);
            
            return {
                question: "Which variable has the LEAST impact on the ball's final position?",
                options: options,
                correct: causes[0].name,
                explanation: `<div><strong>${causes[0].name}</strong> has the smallest impact with only ~${Math.round(causes[0].value)} yards of influence</div><div class="text-sm text-gray-600 mt-2">Others: ${causes.slice(1).map(c => c.name + ' ~' + Math.round(c.value) + 'yds').join(', ')}</div>`
            };
        }


        async function saveScore() {
            if (!state.user) return;
            
            const timestamp = new Date().toISOString();
            const scoreData = {
                name: state.user.name,
                level: state.difficulty,
                tokens: state.user.tokens,
                questionsAnswered: state.user.questionsAnswered,
                correctAnswers: state.user.correctAnswers,
                accuracy: state.user.questionsAnswered > 0 ? 
                    Math.round((state.user.correctAnswers / state.user.questionsAnswered) * 100) : 0,
                bestStreak: state.user.bestStreak,
                timestamp: timestamp,
                displayTime: new Date(timestamp).toLocaleString()
            };
            
            // Use consistent key for each player (no timestamp)
            const key = 'score_' + state.user.name.toLowerCase().replace(/\s+/g, '_');
            
            // Try window.storage first (global), fallback to localStorage
            try {
                // Check if player already has a score
                let existingScore = null;
                try {
                    const result = await window.storage.get(key, true);
                    if (result && result.value) {
                        existingScore = JSON.parse(result.value);
                    }
                } catch (e) {
                    // No existing score
                }
                
                // Only save if new score is better OR no existing score
                if (!existingScore || scoreData.tokens > existingScore.tokens) {
                    await window.storage.set(key, JSON.stringify(scoreData), true);
                }
            } catch (error) {
                // Fallback to localStorage
                try {
                    let existingScore = null;
                    const storedValue = localStorage.getItem(key);
                    if (storedValue) {
                        existingScore = JSON.parse(storedValue);
                    }
                    
                    // Only save if new score is better OR no existing score
                    if (!existingScore || scoreData.tokens > existingScore.tokens) {
                        localStorage.setItem(key, JSON.stringify(scoreData));
                    }
                } catch (e) {
                    console.log('Storage not available:', e.message);
                }
            }
        }

        async function loadLeaderboard() {
            let isGlobal = false;
            let scores = [];
            
            // Try window.storage first (global)
            try {
                const result = await window.storage.list('score_', true);
                if (result && result.keys) {
                    isGlobal = true;
                    for (const key of result.keys) {
                        try {
                            const scoreResult = await window.storage.get(key, true);
                            if (scoreResult && scoreResult.value) {
                                scores.push(JSON.parse(scoreResult.value));
                            }
                        } catch (e) {
                            console.error('Failed to load score:', e);
                        }
                    }
                }
            } catch (error) {
                // Fallback to localStorage
                try {
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('score_')) {
                            const value = localStorage.getItem(key);
                            if (value) {
                                scores.push(JSON.parse(value));
                            }
                        }
                    }
                } catch (e) {
                    console.error('Failed to load from localStorage:', e);
                }
            }
            
            scores.sort((a, b) => {
                if (b.tokens !== a.tokens) return b.tokens - a.tokens;
                return new Date(b.timestamp) - new Date(a.timestamp);
            });
            
            return { scores: scores.slice(0, 50), isGlobal };
        }

        function openLeaderboard() {
            const leaderboardWindow = window.open('', 'Leaderboard', 'width=1100,height=700');
            
            if (!leaderboardWindow) {
                alert('Please allow popups for this site to view the leaderboard!');
                return;
            }
            
            loadLeaderboard().then(data => {
                const { scores, isGlobal } = data;
                
                let html = `<!DOCTYPE html>
<html>
<head>
    <title>Leaderboard</title>
    <script src="https://cdn.tailwindcss.com"><` + `/script>
    <style>
        th { cursor: pointer; user-select: none; }
        th:hover { background-color: #f3f4f6; }
        .sort-arrow { display: inline-block; margin-left: 4px; }
    </style>
</head>
<body class="bg-gradient-to-br from-yellow-400 via-orange-500 to-red-600 p-8">
    <div class="max-w-6xl mx-auto bg-white rounded-2xl shadow-2xl p-8">
        <h1 class="text-4xl font-bold text-center mb-4 bg-gradient-to-r from-yellow-500 to-orange-500 bg-clip-text text-transparent">
            ðŸ† Leaderboard
        </h1>
        <div class="text-center mb-6">
            <span class="inline-block px-4 py-2 rounded-full text-sm font-semibold ${isGlobal ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'}">
                ${isGlobal ? 'ðŸŒ Global Leaderboard - Compete with players worldwide!' : 'ðŸ“Š Personal High Scores - Playing in local mode'}
            </span>
        </div>
        
        <div class="mb-4">
            <label class="font-semibold mr-2">Filter by Level:</label>
            <select id="levelFilter" onchange="filterScores()" class="px-4 py-2 border-2 border-gray-300 rounded-lg">
                <option value="all">All Levels</option>`;
                
                for (let i = 1; i <= 10; i++) {
                    html += `<option value="${i}">Level ${i}: ${difficultyLevels[i-1].name}</option>`;
                }
                
                html += `
            </select>
        </div>`;
                
                if (scores.length === 0) {
                    html += '<div class="text-center py-12"><p class="text-xl text-gray-600">No scores yet. Be the first!</p></div>';
                } else {
                    html += `
        <div class="overflow-x-auto">
            <table class="w-full" id="leaderboardTable">
                <thead>
                    <tr class="border-b-2 border-gray-300">
                        <th class="text-left py-3 px-4 font-bold text-gray-700">Rank</th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700">Player</th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700">Level</th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('tokens')">Tokens <span class="sort-arrow" id="arrow-tokens">â†“</span></th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('accuracy')">Accuracy <span class="sort-arrow" id="arrow-accuracy"></span></th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('correctAnswers')">Correct <span class="sort-arrow" id="arrow-correctAnswers"></span></th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('bestStreak')">Best Streak <span class="sort-arrow" id="arrow-bestStreak"></span></th>
                        <th class="text-left py-3 px-4 font-bold text-gray-700" onclick="sortBy('timestamp')">Last Played <span class="sort-arrow" id="arrow-timestamp"></span></th>
                    </tr>
                </thead>
                <tbody id="leaderboardBody">
                </tbody>
            </table>
        </div>`;
                }
                
                html += `
    </div>
    <script>
        let allScores = ${JSON.stringify(scores)};
        let currentSort = { field: 'tokens', ascending: false };
        let currentFilter = 'all';
        
        const difficultyLevels = ${JSON.stringify(difficultyLevels)};
        
        function renderTable(scoresToShow) {
            const tbody = document.getElementById('leaderboardBody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            scoresToShow.forEach((score, idx) => {
                const medal = idx === 0 ? 'ðŸ¥‡' : idx === 1 ? 'ðŸ¥ˆ' : idx === 2 ? 'ðŸ¥‰' : (idx + 1);
                const rowClass = idx < 3 ? 'bg-yellow-50' : '';
                const row = document.createElement('tr');
                row.className = 'border-b border-gray-200 hover:bg-gray-50 ' + rowClass;
                row.innerHTML = \`
                    <td class="py-3 px-4 font-semibold">\${medal}</td>
                    <td class="py-3 px-4 font-medium">\${score.name}</td>
                    <td class="py-3 px-4"><span class="text-sm">\${difficultyLevels[score.level - 1].name}</span></td>
                    <td class="py-3 px-4"><span class="font-bold text-blue-600">\${score.tokens}</span></td>
                    <td class="py-3 px-4"><span class="text-sm">\${score.accuracy}%</span></td>
                    <td class="py-3 px-4"><span class="font-bold text-green-600">\${score.correctAnswers}</span></td>
                    <td class="py-3 px-4"><span class="font-bold text-purple-600">\${score.bestStreak || 0}</span></td>
                    <td class="py-3 px-4 text-sm text-gray-600">\${score.displayTime}</td>
                \`;
                tbody.appendChild(row);
            });
        }
        
        function sortBy(field) {
            if (currentSort.field === field) {
                currentSort.ascending = !currentSort.ascending;
            } else {
                currentSort.field = field;
                currentSort.ascending = field === 'timestamp';
            }
            
            // Clear all arrows
            document.querySelectorAll('.sort-arrow').forEach(el => el.textContent = '');
            
            // Set current arrow
            const arrow = document.getElementById('arrow-' + field);
            if (arrow) arrow.textContent = currentSort.ascending ? 'â†‘' : 'â†“';
            
            const filtered = filterScores(true);
            const sorted = [...filtered].sort((a, b) => {
                let aVal = a[field];
                let bVal = b[field];
                
                if (field === 'timestamp') {
                    aVal = new Date(aVal);
                    bVal = new Date(bVal);
                }
                
                if (currentSort.ascending) {
                    return aVal > bVal ? 1 : -1;
                } else {
                    return aVal < bVal ? 1 : -1;
                }
            });
            
            renderTable(sorted);
        }
        
        function filterScores(returnOnly = false) {
            currentFilter = document.getElementById('levelFilter').value;
            
            let filtered = allScores;
            if (currentFilter !== 'all') {
                filtered = allScores.filter(s => s.level === parseInt(currentFilter));
            }
            
            if (returnOnly) return filtered;
            
            sortBy(currentSort.field);
        }
        
        // Initial render
        renderTable(allScores);
    <` + `/script>
</body>
</html>`;
                
                leaderboardWindow.document.write(html);
                leaderboardWindow.document.close();
            });
        }

        function selectLevel(level) {
            state.difficulty = level;
            render();
        }

        function startGame() {
            state.showLevelSelect = false;
            state.currentScenarioData = generateScenario(state.difficulty);
            maybeShowConfidenceBoost();
            render();
        }

        function maybeShowConfidenceBoost() {
            // Random chance (20%) to show confidence boost
            if (Math.random() < 0.2 && !state.showConfidenceBoost) {
                state.showConfidenceBoost = true;
                state.hasUsedBoost = false;
                state.boostCountdown = 20;
                // 50% chance to show before question, 50% after seeing the question
                state.boostTiming = Math.random() < 0.5 ? 'before' : 'after';
                
                // Start countdown timer
                if (state.boostTimer) clearInterval(state.boostTimer);
                state.boostTimer = setInterval(() => {
                    state.boostCountdown--;
                    if (state.boostCountdown <= 0) {
                        clearInterval(state.boostTimer);
                        state.showConfidenceBoost = false;
                        state.confidenceMultiplier = 1;
                    }
                    render();
                }, 1000);
            }
        }

        function selectConfidence(multiplier) {
            state.confidenceMultiplier = multiplier;
            state.showConfidenceBoost = false;
            state.hasUsedBoost = true;
            state.boostCardResults = [];
            state.boostLost = false;
            if (state.boostTimer) {
                clearInterval(state.boostTimer);
                state.boostTimer = null;
            }
            render();
        }

        function render() {
            const app = document.getElementById('app');
            
            if (state.showAuth) {
                app.innerHTML = `
                    <div class="min-h-screen golf-bg p-6 flex items-center justify-center">
                        <div class="bg-white rounded-lg shadow-2xl max-w-md w-full">
                            <div class="p-6 rounded-t-lg text-center" style="background: linear-gradient(135deg, var(--augusta-green), var(--augusta-dark));">
                                <div class="text-6xl mb-3">ðŸŒï¸â€â™‚ï¸â›³</div>
                                <h1 class="text-4xl font-bold text-white mb-2">Ball Flight Master</h1>
                                <p class="text-sm" style="color: var(--masters-gold); font-weight: 600; letter-spacing: 1px;">EARN THE GREEN JACKET OF GOLF PHYSICS</p>
                            </div>
                            <div class="p-8">
                                <div class="text-center mb-6">
                                    <p class="text-gray-700 text-lg mb-2 font-semibold">Learn the Science Behind Every Shot</p>
                                    <p class="text-gray-500 text-sm">Learn â€¢ Practice â€¢ Compete</p>
                                </div>
                                <input type="text" id="username" value="${state.username}" 
                                    placeholder="Enter your username" 
                                    class="w-full p-3 border-2 border-gray-300 rounded-lg mb-4 text-lg focus:border-green-600 focus:outline-none">
                                <button onclick="handleLogin()" 
                                    class="w-full py-3 text-white rounded-lg font-semibold text-lg transition-all hover:opacity-90"
                                    style="background: var(--augusta-green);">
                                    â›³ Start Playing
                                </button>
                                <button onclick="openLeaderboard()" 
                                    class="w-full mt-3 py-3 text-white rounded-lg font-semibold transition-all hover:opacity-90"
                                    style="background: var(--masters-gold); color: #000;">
                                    ðŸ† View Leaderboard
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                document.getElementById('username').addEventListener('input', e => {
                    state.username = e.target.value;
                });
                return;
            }

            if (state.showLevelSelect) {
                app.innerHTML = `
                    <div class="min-h-screen golf-bg p-4">
                        <div class="max-w-6xl mx-auto">
                            <div class="bg-white rounded-2xl shadow-2xl p-8 mb-4">
                                <div class="text-center mb-2">
                                    <div class="text-5xl mb-3">â›³</div>
                                    <h1 class="text-4xl font-bold mb-2" style="color: var(--augusta-green);">
                                        Welcome, ${state.username}!
                                    </h1>
                                    <p class="text-gray-600 mb-6">Choose Your Path to the Green Jacket</p>
                                </div>
                                
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    ${difficultyLevels.map(level => `
                                        <div class="border-2 rounded-xl p-6 cursor-pointer hover:shadow-lg transition-all ${state.difficulty === level.level ? 'border-green-600 bg-green-50' : 'border-gray-300'}"
                                            style="${state.difficulty === level.level ? 'border-color: var(--augusta-green);' : ''}"
                                            onclick="selectLevel(${level.level})">
                                            <div class="flex items-start justify-between mb-3">
                                                <div>
                                                    <h3 class="text-xl font-bold text-gray-900">ðŸŒï¸ Level ${level.level}: ${level.name}</h3>
                                                    <p class="text-sm text-gray-600 mt-1">${level.description}</p>
                                                </div>
                                                <span class="px-3 py-1 rounded-full text-sm font-semibold" style="background: var(--masters-gold); color: #000;">
                                                    +${level.baseReward}
                                                </span>
                                            </div>
                                            
                                            <div class="bg-gray-50 rounded-lg p-4 mb-3">
                                                <p class="text-sm text-gray-700">${level.details}</p>
                                            </div>
                                            
                                            <div class="flex gap-4 text-sm">
                                                <div class="flex items-center gap-2">
                                                    <span class="text-gray-600">Cards:</span>
                                                    <span class="font-semibold">${level.cards}</span>
                                                </div>
                                                <div class="flex items-center gap-2">
                                                    <span class="text-gray-600">Reward:</span>
                                                    <span class="font-semibold" style="color: var(--augusta-green);">+${level.baseReward}</span>
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                                
                                <button onclick="startGame()" 
                                    class="w-full mt-6 py-4 text-white rounded-lg font-semibold text-lg hover:shadow-lg transition-all hover:opacity-90"
                                    style="background: var(--augusta-green);">
                                    â›³ Start Level ${state.difficulty}: ${difficultyLevels[state.difficulty - 1].name}
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                return;
            }

            if (!state.currentScenarioData) return;

            const totalCards = difficultyLevels[state.difficulty - 1].cards;
            const card = state.currentScenarioData.cards[state.currentCard - 1];
            const accuracy = state.user.questionsAnswered > 0 ? Math.round((state.user.correctAnswers / state.user.questionsAnswered) * 100) : 0;

            let dataHTML = '';
            for (let [key, item] of Object.entries(state.currentScenarioData.data)) {
                dataHTML += `
                    <div class="bg-gradient-to-br from-blue-50 to-indigo-50 border-2 border-blue-200 rounded-xl p-5 shadow-md hover:shadow-lg transition-all">
                        <div class="flex items-center gap-3 mb-2">
                            <span class="text-3xl">${item.icon}</span>
                            <span class="font-bold text-gray-700 text-sm">${item.label}</span>
                        </div>
                        <div class="text-xl font-bold text-gray-900 mt-2">${item.value}</div>
                    </div>
                `;
            }

            let optionsHTML = '';
            card.options.forEach((opt, idx) => {
                const description = shotShapeDescriptions[opt] || '';
                let btnClass = "w-full text-left p-5 rounded-xl border-2 transition-all font-semibold shadow-md hover:shadow-lg";
                if (!state.showExplanation) {
                    btnClass += state.selectedAnswer === opt ? " border-purple-600 bg-purple-600 text-white" : " border-gray-300 bg-white hover:border-purple-400 hover:bg-purple-50";
                } else {
                    const isCorrect = card.correctBase ? opt.split(' (')[0] === card.correctBase : opt === card.correct;
                    if (isCorrect) btnClass += " border-green-600 bg-green-500 text-white";
                    else if (opt === state.selectedAnswer) btnClass += " border-red-600 bg-red-500 text-white";
                    else btnClass += " border-gray-300 bg-gray-200 text-gray-500";
                }
                
                optionsHTML += `
                    <button onclick="handleAnswer('${opt.replace(/'/g, "\\'")}')" 
                        ${state.showExplanation ? 'disabled' : ''}
                        class="${btnClass}">
                        <div class="text-lg font-bold mb-1">${opt.split(' (')[0]}</div>
                        ${description ? `<div class="shot-description">${description}</div>` : ''}
                    </button>
                `;
            });

            app.innerHTML = `
                <div class="min-h-screen golf-bg p-6">
                    <div class="max-w-5xl mx-auto">
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                            <div class="text-white shadow-lg rounded-lg p-4 text-center" style="background: linear-gradient(135deg, var(--masters-gold), #B8860B);">
                                <p class="text-sm opacity-90">Tokens</p>
                                <p class="text-2xl font-bold text-black">${state.user.tokens}</p>
                            </div>
                            <div class="bg-gradient-to-br from-purple-500 to-pink-500 text-white shadow-lg rounded-lg p-4 text-center">
                                <p class="text-sm opacity-90">Accuracy</p>
                                <p class="text-2xl font-bold">${accuracy}%</p>
                            </div>
                            <div class="bg-gradient-to-br from-green-500 to-teal-500 text-white shadow-lg rounded-lg p-4 text-center">
                                <p class="text-sm opacity-90">Correct</p>
                                <p class="text-2xl font-bold">${state.user.correctAnswers}</p>
                            </div>
                            <div class="bg-gradient-to-br from-blue-500 to-indigo-500 text-white shadow-lg rounded-lg p-4 text-center">
                                <p class="text-sm opacity-90">Streak</p>
                                <p class="text-2xl font-bold">${state.user.currentStreak} ðŸ”¥</p>
                            </div>
                        </div>

                        ${state.hasUsedBoost ? `
                            <div class="mb-6 p-4 rounded-xl shadow-lg ${state.boostLost ? 'bg-gray-300 opacity-75' : 'bg-gradient-to-r from-yellow-400 to-orange-500'}">
                                <div class="text-center">
                                    <div class="text-2xl font-bold ${state.boostLost ? 'text-gray-700' : 'text-white'} mb-2">
                                        ${state.boostLost ? 'âŒ' : 'ðŸŽ¯'} ${state.boostLost ? '<span class="line-through">' + state.confidenceMultiplier + 'x</span>' : state.confidenceMultiplier + 'x'} BOOST ${state.boostLost ? 'LOST' : 'ACTIVE'}
                                    </div>
                                    <div class="flex justify-center items-center gap-2 mb-2">
                                        <span class="${state.boostLost ? 'text-gray-700' : 'text-white'} font-semibold">Progress:</span>
                                        ${Array.from({length: difficultyLevels[state.difficulty - 1].cards}, (_, i) => {
                                            if (i < state.boostCardResults.length) {
                                                return state.boostCardResults[i] ? '<span class="text-2xl">âœ“</span>' : '<span class="text-2xl text-red-600">âœ—</span>';
                                            } else {
                                                return '<span class="text-2xl text-white">â—‹</span>';
                                            }
                                        }).join('')}
                                        <span class="${state.boostLost ? 'text-gray-700' : 'text-white'} text-sm">(${state.boostCardResults.length}/${difficultyLevels[state.difficulty - 1].cards} cards)</span>
                                    </div>
                                    ${state.boostLost ? `
                                        <div class="text-sm text-gray-700 font-semibold">Failed Card ${state.boostCardResults.findIndex(r => !r) + 1}</div>
                                    ` : state.boostCardResults.length > 0 && state.boostCardResults.length < difficultyLevels[state.difficulty - 1].cards ? `
                                        <div class="text-sm text-white font-semibold">Still eligible! ${difficultyLevels[state.difficulty - 1].cards - state.boostCardResults.length} card(s) remaining</div>
                                    ` : ''}
                                </div>
                            </div>
                        ` : ''}

                        <div class="bg-white rounded-lg shadow-lg p-4 mb-6">
                            <div class="flex justify-between items-center">
                                <div>
                                    <h3 class="font-bold text-lg">Level ${state.difficulty} - ${difficultyLevels[state.difficulty - 1].name}</h3>
                                    <p class="text-sm text-gray-600">${difficultyLevels[state.difficulty - 1].description}</p>
                                </div>
                                <button onclick="toggleDifficulty()" class="px-4 py-2 bg-blue-600 text-white rounded-lg mr-2">
                                    Change Level
                                </button>
                                <button onclick="openLeaderboard()" class="px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600">
                                    ðŸ†
                                </button>
                            </div>
                            ${state.showDifficultySelector ? `
                                <div class="mt-4">
                                    <input type="range" min="1" max="10" value="${state.difficulty}" 
                                        oninput="changeDifficulty(this.value)" class="w-full">
                                    <div class="flex justify-between text-xs text-gray-600 mt-2">
                                        ${difficultyLevels.map(d => `<span class="${d.level === state.difficulty ? 'font-bold text-blue-600' : ''}">${d.level}</span>`).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>

                        <div class="bg-white rounded-lg shadow-2xl">
                            <div class="text-white p-6 rounded-t-lg" style="background: linear-gradient(135deg, var(--augusta-green), var(--augusta-dark));">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <h2 class="text-2xl font-bold">Level ${state.difficulty} â€¢ Scenario #${state.scenarioNumber} â€¢ Card ${state.currentCard} of ${totalCards}</h2>
                                        <p class="text-green-100">Base Reward: ${difficultyLevels[state.difficulty - 1].baseReward} tokens</p>
                                    </div>
                                    ${state.currentScenarioData.isTrickScenario ? `
                                        <div class="bg-yellow-500 text-black px-4 py-2 rounded-lg font-bold text-sm shadow-lg animate-pulse">
                                            âš¡ TRICK SCENARIO
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                            <div class="p-6">
                                <div class="mb-6">
                                    <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                                        ${dataHTML}
                                    </div>
                                </div>

                                ${state.showConfidenceBoost && !state.selectedAnswer && state.boostTiming === 'before' ? `
                                    <div class="mb-6 p-6 bg-gradient-to-r from-yellow-400 to-orange-500 border-4 border-yellow-600 rounded-xl shadow-2xl">
                                        <h3 class="text-3xl font-bold text-white mb-3 text-center">ðŸŽ¯ CONFIDENCE BOOSTER! ðŸŽ¯</h3>
                                        <p class="text-white text-lg mb-4 text-center">We're showing you this BEFORE revealing the question! This is a true test of confidence.</p>
                                        <p class="text-white font-semibold mb-4 text-center">Choose your multiplier now, then answer the question:</p>
                                        
                                        <!-- Bomb Countdown -->
                                        <div class="mb-4 bg-white/30 rounded-lg p-3">
                                            <div class="flex items-center justify-between mb-2">
                                                <span class="text-white font-bold">Time remaining: ${state.boostCountdown}s</span>
                                                <span class="text-white font-bold">${state.boostCountdown <= 5 ? 'âš ï¸ HURRY!' : ''}</span>
                                            </div>
                                            <div class="relative h-8 bg-white/20 rounded-full overflow-hidden">
                                                <div class="absolute top-0 left-0 h-full bg-red-500/50 transition-all duration-1000" style="width: ${(state.boostCountdown / 20) * 100}%"></div>
                                                <div class="absolute top-1/2 -translate-y-1/2 transition-all duration-1000" style="left: ${((20 - state.boostCountdown) / 20) * 100}%">
                                                    <span class="text-3xl">${state.boostCountdown <= 3 ? 'ðŸ’¥' : 'ðŸ’£'}</span>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div class="grid grid-cols-3 gap-4">
                                            <button onclick="selectConfidence(1)" class="bg-white text-gray-900 p-4 rounded-lg font-bold text-xl hover:bg-gray-100 transition-all">
                                                1x<br><span class="text-sm">Play it safe</span>
                                            </button>
                                            <button onclick="selectConfidence(2)" class="bg-white text-orange-600 p-4 rounded-lg font-bold text-xl hover:bg-orange-50 transition-all">
                                                2x<br><span class="text-sm">Feeling good!</span>
                                            </button>
                                            <button onclick="selectConfidence(3)" class="bg-white text-red-600 p-4 rounded-lg font-bold text-xl hover:bg-red-50 transition-all">
                                                3x<br><span class="text-sm">All in!</span>
                                            </button>
                                        </div>
                                    </div>
                                ` : ''}

                                ${state.showConfidenceBoost && !state.selectedAnswer && state.boostTiming === 'after' ? `
                                    <div class="mb-6 p-6 bg-gradient-to-r from-blue-400 to-purple-500 border-4 border-blue-600 rounded-xl shadow-2xl">
                                        <h3 class="text-3xl font-bold text-white mb-3 text-center">ðŸŽ¯ CONFIDENCE BOOSTER! ðŸŽ¯</h3>
                                        <p class="text-white text-lg mb-4 text-center">You've seen the question and data. How confident are you?</p>
                                        <p class="text-white font-semibold mb-4 text-center">Choose your multiplier:</p>
                                        
                                        <!-- Bomb Countdown -->
                                        <div class="mb-4 bg-white/30 rounded-lg p-3">
                                            <div class="flex items-center justify-between mb-2">
                                                <span class="text-white font-bold">Time remaining: ${state.boostCountdown}s</span>
                                                <span class="text-white font-bold">${state.boostCountdown <= 5 ? 'âš ï¸ HURRY!' : ''}</span>
                                            </div>
                                            <div class="relative h-8 bg-white/20 rounded-full overflow-hidden">
                                                <div class="absolute top-0 left-0 h-full bg-red-500/50 transition-all duration-1000" style="width: ${(state.boostCountdown / 20) * 100}%"></div>
                                                <div class="absolute top-1/2 -translate-y-1/2 transition-all duration-1000" style="left: ${((20 - state.boostCountdown) / 20) * 100}%">
                                                    <span class="text-3xl">${state.boostCountdown <= 3 ? 'ðŸ’¥' : 'ðŸ’£'}</span>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div class="grid grid-cols-3 gap-4">
                                            <button onclick="selectConfidence(1)" class="bg-white text-gray-900 p-4 rounded-lg font-bold text-xl hover:bg-gray-100 transition-all">
                                                1x<br><span class="text-sm">Not sure</span>
                                            </button>
                                            <button onclick="selectConfidence(2)" class="bg-white text-orange-600 p-4 rounded-lg font-bold text-xl hover:bg-orange-50 transition-all">
                                                2x<br><span class="text-sm">Pretty sure!</span>
                                            </button>
                                            <button onclick="selectConfidence(3)" class="bg-white text-red-600 p-4 rounded-lg font-bold text-xl hover:bg-red-50 transition-all">
                                                3x<br><span class="text-sm">Definitely!</span>
                                            </button>
                                        </div>
                                    </div>
                                ` : ''}

                                <h3 class="font-bold text-2xl mb-4 text-purple-900">${card.question}</h3>

                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                    ${optionsHTML}
                                </div>

                                ${state.showExplanation ? `
                                    <div class="p-4 rounded-lg mb-4 ${state.isCorrect ? 'bg-green-50 border-2 border-green-500' : 'bg-red-50 border-2 border-red-500'}">
                                        ${(() => {
                                            const totalCards = difficultyLevels[state.difficulty - 1].cards;
                                            const baseReward = difficultyLevels[state.difficulty - 1].baseReward;
                                            const isLastCard = state.currentCard >= totalCards;
                                            const allCorrect = state.boostCardResults.every(r => r === true) && state.boostCardResults.length === totalCards;
                                            
                                            if (state.isCorrect) {
                                                if (state.hasUsedBoost && isLastCard) {
                                                    if (allCorrect && !state.boostLost) {
                                                        const multipliedReward = baseReward * state.confidenceMultiplier;
                                                        return `<p class="font-bold text-lg">âœ“ Correct! You got ALL ${totalCards} cards correct!</p><p class="text-lg mt-2">ðŸŽ¯ ${state.confidenceMultiplier}x multiplier applied: <span class="text-green-700">+${multipliedReward} tokens</span> (${baseReward} base Ã— ${state.confidenceMultiplier})</p>`;
                                                    } else {
                                                        return `<p class="font-bold text-lg">âœ“ Correct! +${baseReward} tokens</p><p class="text-sm mt-2 text-red-600">Lost ${state.confidenceMultiplier}x multiplier from earlier incorrect answer</p>`;
                                                    }
                                                } else if (state.hasUsedBoost && !isLastCard) {
                                                    const remaining = totalCards - state.currentCard;
                                                    return `<p class="font-bold text-lg">âœ“ Correct! Still eligible for ${state.confidenceMultiplier}x boost!</p><p class="text-sm mt-2">${remaining} card(s) remaining - get them all correct to earn the bonus!</p>`;
                                                } else {
                                                    return `<p class="font-bold text-lg">âœ“ Correct! +${baseReward} tokens</p>`;
                                                }
                                            } else {
                                                // Wrong answer - show penalty
                                                const penaltyPercent = 0.25 + (state.difficulty - 1) * (0.75 / 9);
                                                const penalty = Math.round(baseReward * penaltyPercent);
                                                
                                                if (state.hasUsedBoost && state.confidenceMultiplier > 1) {
                                                    return `<p class="font-bold text-lg">âœ— Wrong! <span class="text-red-700">-${penalty} tokens</span></p><p class="text-sm mt-2 text-red-600">Lost ${state.confidenceMultiplier}x multiplier AND penalty applied</p>`;
                                                } else {
                                                    return `<p class="font-bold text-lg">âœ— Wrong! <span class="text-red-700">-${penalty} tokens</span></p><p class="text-sm mt-2 text-gray-600">Level ${state.difficulty} penalty: ${Math.round(penaltyPercent * 100)}% of base reward</p>`;
                                                }
                                            }
                                        })()}
                                    </div>
                                    <div class="bg-blue-50 p-4 rounded-lg border-2 border-blue-300 mb-4">
                                        <h4 class="font-bold text-blue-900 mb-3">Explanation:</h4>
                                        <div class="text-gray-800">${card.explanation}</div>
                                    </div>
                                    
                                    <div class="mb-4 p-4 bg-purple-50 border-2 border-purple-300 rounded-lg">
                                        <h4 class="font-bold text-purple-900 mb-3 flex items-center gap-2">
                                            ðŸ’¬ Ask AI About This Scenario
                                        </h4>
                                        <div class="flex gap-2 mb-3">
                                            <input type="text" id="aiQuestion" value="This feature is coming soon!" 
                                                placeholder="This feature is coming soon!" 
                                                class="flex-1 p-3 border-2 border-purple-200 rounded-lg"
                                                disabled>
                                            <button disabled
                                                class="px-6 py-3 bg-gray-400 text-white rounded-lg font-semibold cursor-not-allowed">
                                                Coming Soon
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <button onclick="handleNext()" 
                                        class="w-full py-3 bg-gradient-to-r from-green-600 to-blue-600 text-white rounded-lg font-semibold text-lg">
                                        ${state.currentCard < totalCards ? `Next Card (${state.currentCard + 1} of ${totalCards})` : 'Next Scenario'}
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add level modal overlay if open
            if (state.showLevelModal) {
                app.innerHTML += `
                    <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onclick="closeLevelModal()">
                        <div class="bg-white rounded-2xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-y-auto p-8" onclick="event.stopPropagation()">
                            <div class="flex justify-between items-center mb-6">
                                <h2 class="text-3xl font-bold bg-gradient-to-r from-green-600 to-blue-600 bg-clip-text text-transparent">
                                    Select Difficulty Level
                                </h2>
                                <button onclick="closeLevelModal()" class="text-gray-500 hover:text-gray-700 text-3xl font-bold">Ã—</button>
                            </div>
                            <p class="text-gray-600 mb-6">Change will apply after completing current scenario</p>
                            
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                ${difficultyLevels.map(level => `
                                    <div class="border-2 ${state.difficulty === level.level ? 'border-blue-500 bg-blue-50' : 'border-gray-300'} rounded-xl p-6 cursor-pointer hover:shadow-lg transition-all"
                                        onclick="selectLevel(${level.level}); closeLevelModal();">
                                        <div class="flex items-start justify-between mb-3">
                                            <div>
                                                <h3 class="text-xl font-bold text-gray-900">Level ${level.level}: ${level.name}</h3>
                                                <p class="text-sm text-gray-600 mt-1">${level.description}</p>
                                            </div>
                                            <span class="bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm font-semibold">
                                                +${level.baseReward} tokens
                                            </span>
                                        </div>
                                        
                                        <div class="bg-gray-50 rounded-lg p-4 mb-3">
                                            <p class="text-sm text-gray-700">${level.details}</p>
                                        </div>
                                        
                                        <div class="flex gap-4 text-sm">
                                            <div class="flex items-center gap-2">
                                                <span class="text-gray-600">Cards:</span>
                                                <span class="font-semibold">${level.cards}</span>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <span class="text-gray-600">Reward:</span>
                                                <span class="font-semibold text-green-600">+${level.baseReward}</span>
                                            </div>
                                            <div class="flex items-center gap-2">
                                                <span class="text-gray-600">Penalty:</span>
                                                <span class="font-semibold text-red-600">-${Math.round(level.baseReward * (0.25 + (level.level - 1) * (0.75 / 9)))}</span>
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Add event listener for AI question input
            if (state.showExplanation) {
                const aiInput = document.getElementById('aiQuestion');
                if (aiInput) {
                    aiInput.addEventListener('input', e => {
                        state.aiQuestion = e.target.value;
                    });
                }
            }
        }

        function handleLogin() {
            if (state.username.trim()) {
                state.user = {
                    name: state.username,
                    tokens: 100,
                    questionsAnswered: 0,
                    correctAnswers: 0,
                    currentStreak: 0,
                    bestStreak: 0
                };
                state.showAuth = false;
                state.showLevelSelect = true;
                render();
            }
        }

        function handleAnswer(answer) {
            // Hide confidence boost countdown once answer is selected
            if (state.showConfidenceBoost) {
                state.showConfidenceBoost = false;
                if (state.boostTimer) {
                    clearInterval(state.boostTimer);
                    state.boostTimer = null;
                }
            }
            
            state.selectedAnswer = answer;
            const card = state.currentScenarioData.cards[state.currentCard - 1];
            state.isCorrect = card.correctBase ? answer.split(' (')[0] === card.correctBase : answer === card.correct;
            state.showExplanation = true;
            
            // Track boost progress if active
            if (state.hasUsedBoost && !state.boostLost) {
                state.boostCardResults.push(state.isCorrect);
                if (!state.isCorrect) {
                    state.boostLost = true;
                }
            }
            
            render();
        }

        function handleNext() {
            const totalCards = difficultyLevels[state.difficulty - 1].cards;
            const baseReward = difficultyLevels[state.difficulty - 1].baseReward;
            
            // Determine if boost applies (only on last card of scenario)
            let multiplier = 1;
            let allCardsCorrect = false;
            
            if (state.currentCard >= totalCards && state.hasUsedBoost) {
                // Check if ALL cards were correct
                allCardsCorrect = state.boostCardResults.every(result => result === true) && state.boostCardResults.length === totalCards;
                if (allCardsCorrect && !state.boostLost) {
                    multiplier = state.confidenceMultiplier;
                }
            }
            
            // Calculate reward or penalty
            let reward = 0;
            if (state.isCorrect) {
                reward = baseReward * multiplier;
            } else {
                // Progressive penalty: 25% at level 1, scaling to 100% at level 10
                const penaltyPercent = 0.25 + (state.difficulty - 1) * (0.75 / 9);
                reward = -Math.round(baseReward * penaltyPercent);
            }
            
            state.user.tokens = Math.max(0, state.user.tokens + reward);
            state.user.questionsAnswered++;
            state.user.correctAnswers += state.isCorrect ? 1 : 0;
            state.user.currentStreak = state.isCorrect ? state.user.currentStreak + 1 : 0;
            
            // Update best streak
            if (state.user.currentStreak > state.user.bestStreak) {
                state.user.bestStreak = state.user.currentStreak;
            }
            
            if (state.isCorrect) {
                saveScore();
            }
            
            if (state.currentCard < totalCards) {
                state.currentCard++;
            } else {
                state.scenarioNumber++;
                state.currentCard = 1;
                state.currentScenarioData = generateScenario(state.difficulty);
                // Reset boost tracking for new scenario
                state.confidenceMultiplier = 1;
                state.hasUsedBoost = false;
                state.boostCardResults = [];
                state.boostLost = false;
                // Potentially show confidence boost for next scenario
                maybeShowConfidenceBoost();
            }
            
            state.selectedAnswer = null;
            state.showExplanation = false;
            state.isCorrect = null;
            render();
        }

        async function handleAskAI() {
            if (!state.aiQuestion || !state.aiQuestion.trim() || !state.currentScenarioData) return;
            
            state.isAskingAI = true;
            render();
            
            try {
                const card = state.currentScenarioData.cards[state.currentCard - 1];
                const dataStr = Object.entries(state.currentScenarioData.data)
                    .map(([key, value]) => key + ": " + value)
                    .join('\n');
                
                const response = await fetch("https://api.anthropic.com/v1/messages", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        model: "claude-sonnet-4-20250514",
                        max_tokens: 1000,
                        messages: [{
                            role: "user",
                            content: `You are a golf physics expert helping a student understand ball flight. Here is the current scenario data:\n\n${dataStr}\n\nCurrent Question: ${card.question}\n\nStudent's Question: ${state.aiQuestion}\n\nProvide a helpful, educational response that explains the physics concepts without directly giving away the answer. Help them understand how to think about the problem.`
                        }],
                    })
                });

                const data = await response.json();
                const aiText = data.content?.find(item => item.type === "text")?.text || "I couldn't generate a response. Please try again.";
                state.aiResponse = aiText;
            } catch (error) {
                state.aiResponse = "Sorry, I encountered an error. The AI feature requires an API key to work when self-hosted.";
            } finally {
                state.isAskingAI = false;
                render();
            }
        }

        function toggleDifficulty() {
            state.showLevelModal = !state.showLevelModal;
            render();
        }

        function closeLevelModal() {
            state.showLevelModal = false;
            render();
        }

        function changeDifficulty(level) {
            state.difficulty = parseInt(level);
            state.currentScenarioData = generateScenario(state.difficulty);
            state.currentCard = 1;
            state.scenarioNumber = 1;
            state.selectedAnswer = null;
            state.showExplanation = false;
            render();
        }

        // Initial render
        render();
    </script>
</body>
</html>
